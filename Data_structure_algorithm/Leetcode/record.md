# Leetcode 练习记录<!-- omit in toc -->

- [July Challange](#july-challange)
  - [Week 1](#week-1)
    - [Binary Tree Level Order Traversal II](#binary-tree-level-order-traversal-ii)
    - [Prison Cells After N Days](#prison-cells-after-n-days)
    - [Ugly Number ||](#ugly-number-)
    - [Hamming Distance](#hamming-distance)
- [Linked list practice](#linked-list-practice)
  - [206 Reverse Linked List E](#206-reverse-linked-list-e)
  - [141. Linked List Cycle E](#141-linked-list-cycle-e)
  - [876. Middle of the Linked List E](#876-middle-of-the-linked-list-e)
  - [237. Delete Node in a Linked List E](#237-delete-node-in-a-linked-list-e)
  - [19. Remove Nth Node From End of List M](#19-remove-nth-node-from-end-of-list-m)
  - [83. Remove Duplicates from Sorted List E](#83-remove-duplicates-from-sorted-list-e)
  - [203. Remove Linked List Elements E](#203-remove-linked-list-elements-e)
  - [82. Remove Duplicates from Sorted List II M](#82-remove-duplicates-from-sorted-list-ii-m)
  - [369. Plus One Linked List](#369-plus-one-linked-list)
  - [25 Reverse Nodes in k-Group H](#25-reverse-nodes-in-k-group-h)
- [Tree](#tree)
  - [102 Binary Tree Level Order Traversal M](#102-binary-tree-level-order-traversal-m)
  - [124 Binary Tree Maximum Path Sum H](#124-binary-tree-maximum-path-sum-h)
  - [107. Binary Tree Level Order Traversal II](#107-binary-tree-level-order-traversal-ii)
  - [494. Target Sum](#494-target-sum)
    - [Solution 1 回溯](#solution-1-回溯)
  - [103. Binary Tree Zigzag Level Order Traversal](#103-binary-tree-zigzag-level-order-traversal)
    - [Solution 1 - 奇偶层次遍历](#solution-1---奇偶层次遍历)
  - [100. Same Tree](#100-same-tree)
    - [Solution 1 BFS or DFS](#solution-1-bfs-or-dfs)
  - [101. Symmetric Tree](#101-symmetric-tree)
    - [Solution 1 - BFS or DFS](#solution-1---bfs-or-dfs)
  - [226. Invert Binary Tree](#226-invert-binary-tree)
    - [Solution 1](#solution-1)
  - [257. Binary Tree Paths](#257-binary-tree-paths)
    - [Solution 1 - 回溯法](#solution-1---回溯法)
  - [112. Path Sum](#112-path-sum)
  - [113. Path Sum II](#113-path-sum-ii)
  - [129. Sum Root to Leaf Numbers](#129-sum-root-to-leaf-numbers)
  - [111. Minimum Depth of Binary Tree](#111-minimum-depth-of-binary-tree)
  - [104. Maximum Depth of Binary Tree](#104-maximum-depth-of-binary-tree)
  - [662. Maximum Width of Binary Tree](#662-maximum-width-of-binary-tree)
  - [559. Maximum Depth of N-ary Tree](#559-maximum-depth-of-n-ary-tree)
- [Binary search](#binary-search)
  - [162. Find Peak Element](#162-find-peak-element)
- [String](#string)
  - [3 Longest Substring Without Repeating Characters M](#3-longest-substring-without-repeating-characters-m)
- [Math](#math)
  - [15. 3Sum M](#15-3sum-m)
- [Array](#array)
  - [27. Remove Element E](#27-remove-element-e)
  - [26. Remove Duplicates from Sorted Array E](#26-remove-duplicates-from-sorted-array-e)
  - [80. Remove Duplicates from Sorted Array II M](#80-remove-duplicates-from-sorted-array-ii-m)
  - [189. Rotate Array](#189-rotate-array)
  - [41. First Missing Positive H](#41-first-missing-positive-h)
  - [134. Gas Station M](#134-gas-station-m)
  - [146. LRU Cache](#146-lru-cache)
  - [78. Subsets](#78-subsets)
  - [118. Pascal's Triangle](#118-pascals-triangle)
  - [119. Pascal's Triangle II](#119-pascals-triangle-ii)
  - [169. Majority Element](#169-majority-element)
  - [179. Largest Number](#179-largest-number)
  - [229. Majority Element II](#229-majority-element-ii)
- [Bit Manipulation](#bit-manipulation)
  - [389. Find the Difference E](#389-find-the-difference-e)
  - [136. Single Number E](#136-single-number-e)
  - [137. Single Number II M](#137-single-number-ii-m)
- [Dynamic Programming](#dynamic-programming)
  - [322. Coin Change](#322-coin-change)
  - [300. Longest Increasing Subsequence M](#300-longest-increasing-subsequence-m)
  - [53. Maximum Subarray E](#53-maximum-subarray-e)
  - [518. Coin Change 2 M](#518-coin-change-2-m)
  - [416. Partition Equal Subset Sum M](#416-partition-equal-subset-sum-m)
  - [509. Fibonacci Number E](#509-fibonacci-number-e)
  - [887. Super Egg Drop](#887-super-egg-drop)
    - [Solution 1](#solution-1-1)
    - [Solution 2 二分查找优化](#solution-2-二分查找优化)
  - [1312. Minimum Insertion Steps to Make a String Palindrome](#1312-minimum-insertion-steps-to-make-a-string-palindrome)
  - [1143. Longest Common Subsequence](#1143-longest-common-subsequence)
  - [516. Longest Palindromic Subsequence](#516-longest-palindromic-subsequence)
  - [877. Stone Game](#877-stone-game)
    - [双指针](#双指针)
    - [动规解法](#动规解法)
  - [股票买卖](#股票买卖)
    - [121. Best Time to Buy and Sell Stock](#121-best-time-to-buy-and-sell-stock)
    - [122. Best Time to Buy and Sell Stock II](#122-best-time-to-buy-and-sell-stock-ii)
    - [309. Best Time to Buy and Sell Stock with Cooldown](#309-best-time-to-buy-and-sell-stock-with-cooldown)
    - [714. Best Time to Buy and Sell Stock with Transaction Fee](#714-best-time-to-buy-and-sell-stock-with-transaction-fee)
    - [123. Best Time to Buy and Sell Stock III](#123-best-time-to-buy-and-sell-stock-iii)
    - [188. Best Time to Buy and Sell Stock IV](#188-best-time-to-buy-and-sell-stock-iv)
- [贪心](#贪心)
  - [435. Non-overlapping Intervals](#435-non-overlapping-intervals)
  - [452. Minimum Number of Arrows to Burst Balloons](#452-minimum-number-of-arrows-to-burst-balloons)
- [BFS DFS](#bfs-dfs)
  - [200. Number of Islands](#200-number-of-islands)
    - [Solution BFS 2](#solution-bfs-2)
    - [UF 并查集 1](#uf-并查集-1)
  - [130. Surrounded Regions](#130-surrounded-regions)
    - [Solution BFS 1](#solution-bfs-1)
    - [UF 并查集 2](#uf-并查集-2)
- [并查集](#并查集)
  - [261. Graph Valid Tree](#261-graph-valid-tree)
  - [323. Number of Connected Components in an Undirected Graph](#323-number-of-connected-components-in-an-undirected-graph)
  - [547. Friend Circles](#547-friend-circles)
- [回溯法](#回溯法)
  - [980. Unique Paths III](#980-unique-paths-iii)
- [数据结构相关](#数据结构相关)
  - [146. LRU Cache](#146-lru-cache-1)
  - [460. LFU Cache](#460-lfu-cache)

## July Challange

### Week 1

#### Binary Tree Level Order Traversal II

Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).
```
For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its bottom-up level order traversal as:
[
  [15,7],
  [9,20],
  [3]
]
```
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        if (root == null) return new ArrayList();
        List<List<Integer>> result = new ArrayList();
        Queue<TreeNode> queue = new LinkedList();

        queue.add(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            List<Integer> level = new ArrayList();
            while (size-- > 0) {
                root = queue.poll();
                level.add(root.val);
                if (root.left != null)
                    queue.add(root.left);
                if (root.right != null)
                    queue.add(root.right);
            }
            result.add(0, level);
        }
        
        return result;
    }
}
```

#### Prison Cells After N Days

There are 8 prison cells in a row, and each cell is either occupied or vacant.

Each day, whether the cell is occupied or vacant changes according to the following rules:

If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied.
Otherwise, it becomes vacant.
(Note that because the prison is a row, the first and the last cells in the row can't have two adjacent neighbors.)

We describe the current state of the prison in the following way: cells[i] == 1 if the i-th cell is occupied, else cells[i] == 0.

Given the initial state of the prison, return the state of the prison after N days (and N such changes described above.)

Example 1:
```
Input: cells = [0,1,0,1,1,0,0,1], N = 7
Output: [0,0,1,1,0,0,0,0]
Explanation: 
The following table summarizes the state of the prison on each day:
Day 0: [0, 1, 0, 1, 1, 0, 0, 1]
Day 1: [0, 1, 1, 0, 0, 0, 0, 0]
Day 2: [0, 0, 0, 0, 1, 1, 1, 0]
Day 3: [0, 1, 1, 0, 0, 1, 0, 0]
Day 4: [0, 0, 0, 0, 0, 1, 0, 0]
Day 5: [0, 1, 1, 1, 0, 1, 0, 0]
Day 6: [0, 0, 1, 0, 1, 1, 0, 0]
Day 7: [0, 0, 1, 1, 0, 0, 0, 0]
```

Example 2:
```
Input: cells = [1,0,0,1,0,0,1,0], N = 1000000000
Output: [0,0,1,1,1,1,1,0]
```

Note:
```
cells.length == 8
cells[i] is in {0, 1}
1 <= N <= 10^9
```

Solution1 每次得到新的cells就存在set里面，然后如果新的cells出现了重复，则说明找到了循环节，将N对这个set取模，最后即可得到对应的cells结果

Solution2 用数学方法证明循环 为14

[Reference](https://math.stackexchange.com/questions/3311568/why-does-this-pattern-repeat-after-14-cycles-instead-of-256-can-you-give-a-proo/3311963#3311963)

```java
class Solution {
    public int[] prisonAfterNDays(int[] cells, int N) {
        int[] result = new int[cells.length];
        N= N%14 == 0?14:N%14;
        int i, length = cells.length-1;
        while(N > 0)
        {
            for(i=1; i<length; i++)
            {
                if(cells[i-1]==cells[i+1])
                    result[i]=1;
                else
                    result[i]=0;
            }
            N--;
            cells=Arrays.copyOf(result, length+1);
        }
        return result;
    }
}
```

```
Runtime: 2 ms, faster than 83.39% of Java online submissions for Prison Cells After N Days.
Memory Usage: 40.5 MB, less than 8.64% of Java online submissions for Prison Cells After N Days.
```

#### Ugly Number ||

Write a program to find the n-th ugly number.

Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. 

Example:
```
Input: n = 10
Output: 12
Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.

Note:  

1 is typically treated as an ugly number.
n does not exceed 1690.
```
思路就是按照顺序生成对应的ugly number
```java
class Solution {
    public int nthUglyNumber(int n) {
        int[] ugly = new int[n];
        ugly[0] = 1;
        int indexOf2 = 0, indexOf3 = 0, indexOf5 = 0;
        int factorOf2 = 2, factorOf3 = 3, factorOf5 = 5;
        for(int i=1;i<n;i++){
            int min = Math.min(Math.min(factorOf2,factorOf3),factorOf5);
            ugly[i] = min;
            if(factorOf2 == min)
                factorOf2 = 2*ugly[++indexOf2];
            if(factorOf3 == min)
                factorOf3 = 3*ugly[++indexOf3];
            if(factorOf5 == min)
                factorOf5 = 5*ugly[++indexOf5];
        }
        return ugly[n-1];
    }
}
```

#### Hamming Distance


The [Hamming distance](https://en.wikipedia.org/wiki/Hamming_distance) between two integers is the number of positions at which the corresponding bits are different.

Given two integers x and y, calculate the Hamming distance.
```
Note:
0 ≤ x, y < 231.

Example:

Input: x = 1, y = 4

Output: 2

Explanation:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
```
The above arrows point to positions where the corresponding bits are different.

思路就是位运算

```java
class Solution {
    public int hammingDistance(int x, int y) {
        int hammingCount = 0;
        int maxJudgementNum = Math.max(Integer.toBinaryString(x).length(),Integer.toBinaryString(y).length());
        for(int i=0;i<maxJudgementNum;i++){
            if((x&1)!=(y&1)){
                hammingCount++;
            }
            x >>=1;
            y >>=1;
        }
        return hammingCount;
    }
}
```

## Linked list practice

### 206 Reverse Linked List E

Reverse a singly linked list.

Example:
```
Input: 1->2->3->4->5->NULL
Output: 5->4->3->2->1->NULL
```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null){
            return null;
        }
        ListNode current = head;
        ListNode last = null;
        while(current!=null){
            ListNode temp = current.next;
            current.next = last;
            last = current;
            current = temp;
        }
        head = last;
        return head;
    }
    
}
```

```
Runtime: 0 ms, faster than 100.00% of Java online submissions for Reverse Linked List.
Memory Usage: 40.5 MB, less than 5.05% of Java online submissions for Reverse Linked List.
```

### 141. Linked List Cycle E

Given a linked list, determine if it has a cycle in it.

To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.

Example 1:
```
Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where tail connects to the second node.
```
![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)

Example 2:
```
Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where tail connects to the first node.
```
![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png)

用快慢指针，一个跨两步遍历，一个一步一步遍历，在有环的情况下，两个指针会碰在一起

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head == null) return false;
        ListNode fast = head;
        ListNode slow = head;
        while(fast!=null&&fast.next != null && slow != null){
            fast = fast.next.next;
            slow = slow.next;
            if(fast == slow) return true;
        }
        return false;
    }
}
```

```
Runtime: 0 ms, faster than 100.00% of Java online submissions for Linked List Cycle.
Memory Usage: 39.7 MB, less than 45.18% of Java online submissions for Linked List Cycle.
```
### 876. Middle of the Linked List E

Given a non-empty, singly linked list with head node head, return a middle node of linked list.

If there are two middle nodes, return the second middle node.

Example 1:
```
Input: [1,2,3,4,5]
Output: Node 3 from this list (Serialization: [3,4,5])
The returned node has value 3.  (The judge's serialization of this node is [3,4,5]).
Note that we returned a ListNode object ans, such that:
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.
```

Example 2:
```
Input: [1,2,3,4,5,6]
Output: Node 4 from this list (Serialization: [4,5,6])
Since the list has two middle nodes with values 3 and 4, we return the second one.
```

Note:

The number of nodes in the given list will be between 1 and 100.

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode middleNode(ListNode head) {
        if(head==null) return null;
        
        ListNode fast = head;
        ListNode slow = head;
        
        while(fast!=null&&fast.next!=null){
            fast = fast.next.next;
            slow = slow.next;
        }
        
        return slow;
    }
}
```

```
Runtime: 0 ms, faster than 100.00% of Java online submissions for Middle of the Linked List.
Memory Usage: 38.5 MB, less than 9.96% of Java online submissions for Middle of the Linked List.
```

### 237. Delete Node in a Linked List E

Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.

Given linked list -- head = [4,5,1,9], which looks like following:

Example 1:
```
Input: head = [4,5,1,9], node = 5
Output: [4,1,9]
Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.
```
Example 2:
```
Input: head = [4,5,1,9], node = 1
Output: [4,5,9]
Explanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.
```

Note:
```
The linked list will have at least two elements.
All of the nodes' values will be unique.
The given node will not be the tail and it will always be a valid node of the linked list.
Do not return anything from your function.
```

直接赋值遍历即可

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public void deleteNode(ListNode node) {
        
        while(node.next!=null){
            node.val = node.next.val;
            if(node.next.next==null){
                node.next = null;
                break;
            }
            node = node.next;
        }
    }
}
```

```
Runtime: 0 ms, faster than 100.00% of Java online submissions for Delete Node in a Linked List.
Memory Usage: 41.5 MB, less than 5.02% of Java online submissions for Delete Node in a Linked List.
```

### 19. Remove Nth Node From End of List M

Given a linked list, remove the n-th node from the end of list and return its head.

Example:
```
Given linked list: 1->2->3->4->5, and n = 2.

After removing the second node from the end, the linked list becomes 1->2->3->5.
```

Note:

Given n will always be valid.

Follow up:

Could you do this in one pass?

思路就是双指针，一个指向尾，另一个和尾巴保持n的距离，最后用链表删除结点的方法即可。这里有个情况就是删除的节点是头节点，这时候直接返回```head.next```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode tail = head;
        ListNode targetPre = head;
        while(n>0&&tail.next!=null){
            tail = tail.next;
            n--;
        }
        if(n==0){
            while(tail.next!=null){
                tail=tail.next;
                targetPre=targetPre.next;
            }
            targetPre.next = targetPre.next.next;
        }else{
            return head.next;
        }
        return head;
    }
}
```

```
Runtime: 0 ms, faster than 100.00% of Java online submissions for Remove Nth Node From End of List.
Memory Usage: 39.4 MB, less than 11.40% of Java online submissions for Remove Nth Node From End of List.
```

### 83. Remove Duplicates from Sorted List E

Given a sorted linked list, delete all duplicates such that each element appear only once.

Example 1:
```
Input: 1->1->2
Output: 1->2
```
Example 2:
```
Input: 1->1->2->3->3
Output: 1->2->3
```
双指针，一个往后移动作为判断位，一个只有在遇到了不同数值的时候才会后移

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head==null || head.next==null){
            return head;
        }
        ListNode judge = head.next;
        ListNode current = head;
        while(judge!=null){
            if(judge.val!=current.val){
                current.next.val = judge.val;
                current=current.next;
            }
            judge=judge.next;
        }
        current.next = null;
        return head;
    }
}
```

```
Runtime: 1 ms, faster than 26.30% of Java online submissions for Remove Duplicates from Sorted List.
Memory Usage: 41.4 MB, less than 10.33% of Java online submissions for Remove Duplicates from Sorted List.
```

### 203. Remove Linked List Elements E

Remove all elements from a linked list of integers that have value val.

Example:
```
Input:  1->2->6->3->4->5->6, val = 6
Output: 1->2->3->4->5
```

思路很简单，链表删除，这里做个小处理就是加个空head头，这样比较方便删除元素

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode myHead = new ListNode();
        myHead.next=head;
        ListNode pre = myHead;
        ListNode current = head;
        
        while(current!=null){
            if(current.val==val){
                pre.next=current.next;
                current=pre.next;
            }else{
                current=current.next;
                pre=pre.next;
            }
        }
        return myHead.next;
    }
}
```

```
Runtime: 1 ms, faster than 87.02% of Java online submissions for Remove Linked List Elements.
Memory Usage: 47.1 MB, less than 5.01% of Java online submissions for Remove Linked List Elements.
```

### 82. Remove Duplicates from Sorted List II M

Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.

Return the linked list sorted as well.

Example 1:
```
Input: 1->2->3->3->4->4->5
Output: 1->2->5
```
Example 2:
```
Input: 1->1->1->2->3
Output: 2->3
```

递归一波

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if( head != null && head.next != null) {            
		    if(head.next.val != head.val) {
			    head.next = deleteDuplicates(head.next);
		    } else {
			    while(head.next != null && head.val == head.next.val)
				    head = head.next;
			    return deleteDuplicates(head.next);
		    }
	    }
	    return head;
    }
}
```

```
Runtime: 1 ms, faster than 31.15% of Java online submissions for Remove Duplicates from Sorted List II.
Memory Usage: 40.9 MB, less than 11.04% of Java online submissions for Remove Duplicates from Sorted List II.
```

### 369. Plus One Linked List

Given a non-negative integer represented as non-empty a singly linked list of digits, plus one to the integer.

The digits are stored such that the most significant digit is at the head of the list.

Example

```
Input: 1->2->3
Output: 1->2->4
```

现将链表翻转然后找到第一位不为 9 的数字，加一再翻转回来，遍历过的为 9 的数字均置为 0 。

* 24 Swap Nodes in Pairs
  * recursively
    * 16 ms 99.75% faster	13.8 MB	6.6% memory less python3
* 328 Odd Even Linked List
  * iteratiely
    * 36 ms	97% faster 15.9 MB 8.33% memory less python3
* 92 Reverse Linked List II
  * iteratively
    * 28 ms	82% faster 14 MB 7.4% memory less python3


### 25 Reverse Nodes in k-Group H

Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.

k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.

```

Example:

Given this linked list: 1->2->3->4->5

For k = 2, you should return: 2->1->4->3->5

For k = 3, you should return: 3->2->1->4->5
```

Note:

Only constant extra memory is allowed.
You may not alter the values in the list's nodes, only nodes itself may be changed.


Solution 1

思路就是一遍遍历，然后每当计数等于k的时候就将这一串翻转

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if(head == null){
            return null;
        }
        if(k<2){
            return head;
        }
        ListNode fakeHead = new ListNode(0,head); // 创建虚假head
        
        ListNode currentBeforeReverseNode = fakeHead;
        ListNode currentNavigateNode = head;
        
        
        int count = 0;
        while(currentNavigateNode!=null){
            count++;
            if(count>=k){
                ListNode temp = currentNavigateNode.next; // 因为反转过后currentNavigateNode的next会发生变化，先保存一下
                ListNode tempB = currentBeforeReverseNode.next; // 反转后翻转链的前置节点的next会变成后面串的前置节点
                this.reverseSubLinkedList(currentBeforeReverseNode,currentNavigateNode.next);
                currentNavigateNode = temp;
                currentBeforeReverseNode = tempB;
                count=0;
            }else{
                currentNavigateNode = currentNavigateNode.next;
            }
        }
        return fakeHead.next;
    }
    public void reverseSubLinkedList(ListNode beforeNode,ListNode afterNode){
        // beforeNode 是需要反转的链表的前一个节点
        // afterNode 是需要反转的链表的后一个节点
        ListNode currentNode = beforeNode.next;
        ListNode nextNode = currentNode.next;
        
        currentNode.next = afterNode;
        while(nextNode!=afterNode){
            ListNode temp = nextNode.next; // 保存一下next指向
            nextNode.next = currentNode; // 将currentNode 和 nextNode翻转
            currentNode = nextNode;
            nextNode = temp;
        }
        // 将befroeNode指向反转后的尾巴
        beforeNode.next = currentNode;
    }
}
```

```
Runtime: 0 ms, faster than 100.00% of Java online submissions for Reverse Nodes in k-Group.
Memory Usage: 39.9 MB, less than 33.82% of Java online submissions for Reverse Nodes in k-Group.
```

---

## Tree

* 144 Binary Tree Preorder Traversal 进阶：迭代方法
  * recursively
    * 28 ms 73% faster	13.7 MB	91% memory less python3
* 94 Binary Tree Inorder Traversal
  * recursively
    * 32 ms	45% faster 14 MB 5% memory less	python3
* 145 Binary Tree Postorder Traversal
  * recursively
    * 32 ms	44% faster 13.8 MB	57% memory less python3

### 102 Binary Tree Level Order Traversal M

Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

For example:
```
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its level order traversal as:
[
  [3],
  [9,20],
  [15,7]
]
```

Solution 1

思路是层次遍历，但是因为返回的结果需要注意如何单独存储每一层的信息，详情见代码.

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        // 初始化结果存储
        List<List<Integer>> res = new ArrayList<>();
        
        if(root==null){
            return res;
        }
        
        // 初始化子节点队列
        LinkedList<TreeNode> children = new LinkedList<>();
        children.addLast(root);
        
        int currentLevelChildNum = 1; // 当前层节点数
        int nextLevelChildNum = 0; // 下一层节点数
        
        List<Integer> currentLevelVal = new ArrayList<>(); // 当前层节点值存储
        
        while(children.size()!=0){
            // 取出节点
            TreeNode current = children.removeFirst();
            // 将此节点值放入当前层次中
            currentLevelVal.add(current.val);
            // 当前层次计数减一
            currentLevelChildNum--;
            
            
            // 将子节点加入队列
            if(current.left!=null){
                children.addLast(current.left);
                // 下一层节点数计数加一
                nextLevelChildNum++;
            }
            if(current.right!=null){
                children.addLast(current.right);
                // 下一层节点数计数加一
                nextLevelChildNum++;
            }
            
            // 判断当前层是否结束遍历
            if(currentLevelChildNum==0){
                // 存储当前层的遍历结果
                res.add(currentLevelVal);
                // 注意不可以用clear来清空currentLevelVal存储，因为存到res中的是引用，结果就是res中的结果也都被清空了
                // 清空当前层存储
                currentLevelVal=new ArrayList<Integer>();
                // 进入下一层
                currentLevelChildNum = nextLevelChildNum;
                // 下一层计数清零
                nextLevelChildNum = 0;
            }
        }
        
        return res;
        
        
    }
}
```

```
Runtime: 0 ms, faster than 100.00% of Java online submissions for Binary Tree Level Order Traversal.
Memory Usage: 39.4 MB, less than 75.36% of Java online submissions for Binary Tree Level Order Traversal.
```

### 124 Binary Tree Maximum Path Sum H

Given a non-empty binary tree, find the maximum path sum.

For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.

Example 1:
```
Input: [1,2,3]

       1
      / \
     2   3

Output: 6
```
Example 2:
```
Input: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

Output: 42
```

Solution 1

深度优先搜索+剪枝

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    private int res = Integer.MIN_VALUE;
    
    private int dfs(TreeNode root){
            
        if(root == null)
            return 0;

        int rootVal = root.val;
        int left = Math.max(0,this.dfs(root.left)); // 深度优先搜索寻找左最大
        int right = Math.max(0,this.dfs(root.right)); // 深度优先搜索找右最大
        // 这里和0取更大是为了去掉子节点最大为负数的情况，这样相当于直接剪枝

        int val = rootVal + left + right ; // 计算包含当前根的最大路径

        res = Math.max(val,res); // 更新最大

        return rootVal+Math.max(left,right); // 将其作为路径之一返回
    }
    
    public int maxPathSum(TreeNode root) {
        // 深度优先搜索，因为要找的是某一结点到某一结点的最大路径，可以考虑回溯的思路
        
        this.res = root.val;
        
        dfs(root);
        
        return res;
    }
}
```

```
Runtime: 0 ms, faster than 100.00% of Java online submissions for Binary Tree Maximum Path Sum.
Memory Usage: 41.4 MB, less than 40.11% of Java online submissions for Binary Tree Maximum Path Sum.
```

### 107. Binary Tree Level Order Traversal II

Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).

For example:
Given binary tree [3,9,20,null,null,15,7],
```
    3
   / \
  9  20
    /  \
   15   7
```
return its bottom-up level order traversal as:
```
[
  [15,7],
  [9,20],
  [3]
]
```

Solution 1: ```Queue``` and ```Collections.reverse()```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        if (root == null) return new ArrayList();
        List<List<Integer>> result = new ArrayList();
        Queue<TreeNode> queue = new LinkedList();

        queue.add(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            List<Integer> level = new ArrayList();
            while (size-- > 0) {
                root = queue.poll();
                level.add(root.val);
                if (root.left != null)
                    queue.add(root.left);
                if (root.right != null)
                    queue.add(root.right);
            }
            result.add(level);
        }

        Collections.reverse(result);
        return result;
    }
}
```

```
Runtime: 2 ms, faster than 18.87% of Java online submissions for Binary Tree Level Order Traversal II.
Memory Usage: 39.8 MB, less than 43.95% of Java online submissions for Binary Tree Level Order Traversal II.
```

Solution 2: Use append ```ArrayList.add(0,item)``` 省却了翻转，快一倍
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        if (root == null) return new ArrayList();
        List<List<Integer>> result = new ArrayList();
        Queue<TreeNode> queue = new LinkedList();

        queue.add(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            List<Integer> level = new ArrayList();
            while (size-- > 0) {
                root = queue.poll();
                level.add(root.val);
                if (root.left != null)
                    queue.add(root.left);
                if (root.right != null)
                    queue.add(root.right);
            }
            result.add(0, level);
        }
        
        return result;
    }
}
```

```
Runtime: 1 ms, faster than 80.39% of Java online submissions for Binary Tree Level Order Traversal II.
Memory Usage: 39.2 MB, less than 98.31% of Java online submissions for Binary Tree Level Order Traversal II.
```

Solution 3: 用 stack

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        if (root == null) return new ArrayList();
        List<List<Integer>> result = new ArrayList();
        Queue<TreeNode> queue = new LinkedList();
        Stack<List<Integer>> stack = new Stack();

        queue.add(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            List<Integer> level = new ArrayList();
            while (size-- > 0) {
                root = queue.poll();
                level.add(root.val);
                if (root.left != null)
                    queue.add(root.left);
                if (root.right != null)
                    queue.add(root.right);
            }
            stack.add(level);
        }

        while (!stack.isEmpty())
            result.add(stack.pop());

        return result;
    }
}
```

```
Runtime: 1 ms, faster than 80.39% of Java online submissions for Binary Tree Level Order Traversal II.
Memory Usage: 39.7 MB, less than 49.37% of Java online submissions for Binary Tree Level Order Traversal II.
```

### 494. Target Sum

You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.

Find out how many ways to assign symbols to make sum of integers equal to target S.

```
Example 1:

Input: nums is [1, 1, 1, 1, 1], S is 3. 
Output: 5
Explanation: 

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3
```

There are 5 ways to assign symbols to make the sum of nums be target 3.
 
Constraints:

* The length of the given array is positive and will not exceed 20.
* The sum of elements in the given array will not exceed 1000.
* Your output answer is guaranteed to be fitted in a 32-bit integer.

#### Solution 1 回溯

```java
class Solution {
    private int result = 0;
    
    private void helper(int[] nums,int index, int rest){
        // 回溯函数
        // base case
        if(index == nums.length){
            if(rest==0){
                result++;
            }
            return ;
        }
        
        // 考虑 +
        rest -= nums[index];
        helper(nums,index+1,rest);
        // 回溯
        rest += nums[index];
        
        // 考虑 -
        rest += nums[index];
        helper(nums,index+1,rest);
        // 回溯
        rest -= nums[index];
        
        
    }
    
    public int findTargetSumWays(int[] nums, int S) {
        if(nums.length==0){
            return 0;
        }    
        
        helper(nums,0,S);
        
        return result;
    }
}
```

时间复杂度为$2^n$

```
Runtime: 561 ms, faster than 16.79% of Java online submissions for Target Sum.
Memory Usage: 37.3 MB, less than 80.83% of Java online submissions for Target Sum.
```

### 103. Binary Tree Zigzag Level Order Traversal

Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).

```
For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its zigzag level order traversal as:
[
  [3],
  [20,9],
  [15,7]
]
```

#### Solution 1 - 奇偶层次遍历

基本思路为层次遍历。

使用两个栈来保存奇偶层的遍历，奇数层存入奇数栈，取出的时候孩子先从左到右遍历存入偶数栈。偶数层存入偶数栈，取出的时候孩子先从右到左遍历存入奇数栈

```java
/**
* Definition for a binary tree node.
* public class TreeNode {
*     int val;
*     TreeNode left;
*     TreeNode right;
*     TreeNode() {}
*     TreeNode(int val) { this.val = val; }
*     TreeNode(int val, TreeNode left, TreeNode right) {
*         this.val = val;
*         this.left = left;
*         this.right = right;
*     }
* }
*/
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        
        // 结果存放
        List<List<Integer>> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        // 两个栈，分别遍历奇偶层次
        LinkedList<TreeNode> leftStack = new LinkedList<>();
        LinkedList<TreeNode> rightStack = new LinkedList<>();

        // 起始为奇遍历
        leftStack.addLast(root);
        boolean flag = false; // 代表奇数层次遍历

        // 开始奇偶层次遍历
        while (leftStack.size() != 0 || rightStack.size() != 0) {

            List<Integer> temp = new ArrayList<>(); // 临时存放每层遍历结果

            if (!flag) {
                // 奇数层
                while (leftStack.size() != 0) {
                    TreeNode leftItem = leftStack.removeLast();
                    temp.add(leftItem.val);
                    if (leftItem.left != null) {
                        rightStack.addLast(leftItem.left);
                    } 
                    if (leftItem.right != null) {
                        rightStack.addLast(leftItem.right);
                    }

                }

                flag = true;
            } else {
                // 偶数层
                while (rightStack.size() != 0) {
                    TreeNode rightItem = rightStack.removeLast();
                    temp.add(rightItem.val);
                    if (rightItem.right != null) {
                        leftStack.addLast(rightItem.right);
                    } 
                    if (rightItem.left != null) {
                        leftStack.addLast(rightItem.left);
                    }

                }

                flag = false;
            }

            res.add(temp);
        }
        return res;
    }
}
```

```
Runtime: 0 ms, faster than 100.00% of Java online submissions for Binary Tree Zigzag Level Order Traversal.
Memory Usage: 39.5 MB, less than 63.82% of Java online submissions for Binary Tree Zigzag Level Order Traversal.
```

### 100. Same Tree

Given two binary trees, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical and the nodes have the same value.

```
Example 1:

Input:     1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

Output: true
Example 2:

Input:     1         1
          /           \
         2             2

        [1,2],     [1,null,2]

Output: false
Example 3:

Input:     1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

Output: false
```

#### Solution 1 BFS or DFS

广度优先搜索和深度优先搜索均可，两种不同的遍历节点策略

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean BFS(TreeNode p, TreeNode q){
        // 广度优先搜索
        // 使用 queue 数据结构存储节点
        LinkedList<TreeNode> queueP = new LinkedList<>();
        LinkedList<TreeNode> queueQ = new LinkedList<>();
        queueP.addLast(p);
        queueQ.addLast(q);

        while(queueP.size()!=0&&queueQ.size()!=0){
            TreeNode pItem = queueP.removeLast();
            TreeNode qItem = queueQ.removeLast();
            if(pItem!=null&&qItem!=null&&pItem.val==qItem.val){
                // 两者相同
                queueP.addFirst(pItem.right);
                queueQ.addFirst(qItem.right);
                queueP.addFirst(pItem.left);
                queueQ.addFirst(qItem.left);

            }else if(pItem==qItem){
                // 均为 null
                continue;
            }else{
                // 既不为空也不相同
                return false;
            }
        }

        // 对比完所有节点
        return true;
    }
    public boolean DFS(TreeNode p, TreeNode q) {
        // 深度优先搜索
        // 使用 stack 数据结构存储节点
        LinkedList<TreeNode> stackP = new LinkedList<>();
        LinkedList<TreeNode> stackQ = new LinkedList<>();
        stackP.addLast(p);
        stackQ.addLast(q);

        while(stackP.size()!=0&&stackQ.size()!=0){
            TreeNode pItem = stackP.removeLast();
            TreeNode qItem = stackQ.removeLast();

            if(pItem!=null&&qItem!=null&&pItem.val==qItem.val){
                // 两者相同
                stackP.addLast(pItem.right);
                stackQ.addLast(qItem.right);
                stackP.addLast(pItem.left);
                stackQ.addLast(qItem.left);

            }else if(pItem==qItem){
                // 均为 null
                continue;
            }else{
                // 既不为空也不相同
                return false;
            }
        }

        // DFS 对比完所有节点
        return true;

    }

    public boolean isSameTree(TreeNode p, TreeNode q) {
        return BFS(p,q);
    }
}
```

BFS
```
Runtime: 0 ms, faster than 100.00% of Java online submissions for Same Tree.
Memory Usage: 36.5 MB, less than 98.21% of Java online submissions for Same Tree.
```

DFS
```
Runtime: 0 ms, faster than 100.00% of Java online submissions for Same Tree.
Memory Usage: 37 MB, less than 56.72% of Java online submissions for Same Tree.
```

stack 的结构比 queue 占用空间更多，符合直觉

### 101. Symmetric Tree

Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).

```
For example, this binary tree [1,2,2,3,4,4,3] is symmetric:

    1
   / \
  2   2
 / \ / \
3  4 4  3
 

But the following [1,2,2,null,3,null,3] is not:

    1
   / \
  2   2
   \   \
   3    3
```

#### Solution 1 - BFS or DFS

修改改一下 100中的方法 就可以直接用了，考虑对比根节点下两个子树是否对称一样，修改一下遍历的方向即可

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean BFS(TreeNode p, TreeNode q){
        // 广度优先搜索
        // 使用 queue 数据结构存储节点
        LinkedList<TreeNode> queueP = new LinkedList<>();
        LinkedList<TreeNode> queueQ = new LinkedList<>();
        queueP.addLast(p);
        queueQ.addLast(q);

        while(queueP.size()!=0&&queueQ.size()!=0){
            TreeNode pItem = queueP.removeLast();
            TreeNode qItem = queueQ.removeLast();
            if(pItem!=null&&qItem!=null&&pItem.val==qItem.val){
                // 两者相同
                queueP.addFirst(pItem.right);
                queueQ.addFirst(qItem.left);
                queueP.addFirst(pItem.left);
                queueQ.addFirst(qItem.right);

            }else if(pItem==qItem){
                // 均为 null
                continue;
            }else{
                // 既不为空也不相同
                return false;
            }
        }

        // 对比完所有节点
        return true;
    }
    public boolean isSymmetric(TreeNode root) {
        if(root==null||root.right==null&&root.left==null){
            return true;
        }
        return BFS(root.left,root.right);
    }
}
```

```
Runtime: 1 ms, faster than 38.39% of Java online submissions for Symmetric Tree.
Memory Usage: 39 MB, less than 36.49% of Java online submissions for Symmetric Tree.
```

### 226. Invert Binary Tree

Invert a binary tree.
```
Example:

Input:

     4
   /   \
  2     7
 / \   / \
1   3 6   9
Output:

     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

#### Solution 1 

广度优先搜索并交换孩子

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public void exchangeNode(TreeNode node){
        // 交换两个节点
        TreeNode temp = node.left;
        node.left = node.right;
        node.right = temp;
        
        
    }
    public void BFS(TreeNode node){
        if(node==null)
            return ;
        // 广度优先搜索
        // 使用 queue 数据结构存储节点
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.addLast(node);

        while(queue.size()!=0){
            TreeNode item = queue.removeFirst();
            exchangeNode(item);
            if(item.left!=null){
                queue.addLast(item.left);
            }
            if(item.right!=null){
                queue.addLast(item.right);
            }
            
            
        }

    }
    public TreeNode invertTree(TreeNode root) {
        BFS(root);
        return root;
    }
}
```

```
Runtime: 0 ms, faster than 100.00% of Java online submissions for Invert Binary Tree.
Memory Usage: 36.9 MB, less than 76.92% of Java online submissions for Invert Binary Tree.
```

### 257. Binary Tree Paths

Given a binary tree, return all root-to-leaf paths.

Note: A leaf is a node with no children.
```
Example:

Input:

   1
 /   \
2     3
 \
  5

Output: ["1->2->5", "1->3"]

Explanation: All root-to-leaf paths are: 1->2->5, 1->3
```

#### Solution 1 - 回溯法

深度优先遍历，使用回溯

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
import java.lang.*;
class Solution {
    public void allPaths(TreeNode root, LinkedList<TreeNode> stack,List<String> res){
        if(root.left==null&&root.right==null){
            // 到达叶子节点，记录结果
            // 默认 root 首先装入
            Iterator it = stack.iterator();
            StringBuilder tempRes = new StringBuilder();
            
            TreeNode tempRoot = stack.removeFirst();
            tempRes.append(tempRoot.val);
            for(TreeNode node : stack){
                if(node!=null){
                    tempRes.append("->"+node.val);
                }
            }
            res.add(tempRes.toString());
            stack.addFirst(tempRoot);
            return;
        }
        
        if(root.left!=null){
            stack.addLast(root.left);
            allPaths(root.left,stack,res);
            stack.removeLast();
        }
        
        if(root.right!=null){
            stack.addLast(root.right);
            allPaths(root.right,stack,res);
            stack.removeLast();
        }
        
        
    }
    public List<String> binaryTreePaths(TreeNode root) {
        // 回溯法
        List<String> res = new ArrayList<String>();
        if(root==null){
            return res;
        }
        
        LinkedList<TreeNode> stack = new LinkedList<>();
        
        stack.addLast(root);
        allPaths(root,stack,res);
        
        return res;
        
    }
}
```

```
Runtime: 13 ms, faster than 15.37% of Java online submissions for Binary Tree Paths.
Memory Usage: 40 MB, less than 31.43% of Java online submissions for Binary Tree Paths.
```

### 112. Path Sum

```
Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.

Note: A leaf is a node with no children.

Example:

Given the below binary tree and sum = 22,

      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1
return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    
    private boolean helper(TreeNode node,int sum){
        if(node==null)
            return false;
        if(node.left==null&&node.right==null&&sum==node.val){
            // 到达叶子
            return true;
        }
        
        return this.helper(node.left,sum-node.val)||this.helper(node.right,sum-node.val);
        
    }
    public boolean hasPathSum(TreeNode root, int sum) {
        // 回溯法
        return this.helper(root,sum);
    }
}
```

```
Runtime: 0 ms, faster than 100.00% of Java online submissions for Path Sum.
Memory Usage: 39.1 MB, less than 89.35% of Java online submissions for Path Sum.
```

### 113. Path Sum II

```
Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.

Note: A leaf is a node with no children.

Example:

Given the below binary tree and sum = 22,

      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1
Return:

[
   [5,4,11,2],
   [5,8,4,5]
]
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    
    private List<List<Integer>> res;
    private LinkedList<Integer> tempList;
    private void helper(TreeNode node,int sum){
        if(node!=null){
            tempList.addLast(node.val);
        }else{
            return;
        }
        if(node.left==null&&node.right==null){
            if(sum==node.val){
                res.add(new ArrayList<Integer>(this.tempList));
                tempList.removeLast();
                return;
            }else{
                tempList.removeLast();
                return;
            }
            
        }
        this.helper(node.left,sum-node.val);
        this.helper(node.right,sum-node.val);
        tempList.removeLast();
    }
    
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        // 回溯法
        res = new ArrayList<>();
        tempList = new LinkedList<>();
        
        
        this.helper(root,sum);
        
        return res;
        
    }
}
```

### 129. Sum Root to Leaf Numbers

```
Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.

An example is the root-to-leaf path 1->2->3 which represents the number 123.

Find the total sum of all root-to-leaf numbers.

Note: A leaf is a node with no children.

Example:

Input: [1,2,3]
    1
   / \
  2   3
Output: 25
Explanation:
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.
Therefore, sum = 12 + 13 = 25.
Example 2:

Input: [4,9,0,5,1]
    4
   / \
  9   0
 / \
5   1
Output: 1026
Explanation:
The root-to-leaf path 4->9->5 represents the number 495.
The root-to-leaf path 4->9->1 represents the number 491.
The root-to-leaf path 4->0 represents the number 40.
Therefore, sum = 495 + 491 + 40 = 1026.
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    private List<List<Integer>> res;
    private LinkedList<Integer> tempList;
    private void helper(TreeNode node){
        if(node!=null){
            tempList.addLast(node.val);
        }else{
            return;
        }
        if(node.left==null&&node.right==null){
            res.add(new ArrayList<Integer>(this.tempList));
            tempList.removeLast();
            return;
            
        }
        this.helper(node.left);
        this.helper(node.right);
        tempList.removeLast();
    }
    public int sumNumbers(TreeNode root) {
        // 回溯法
        res = new ArrayList<>();
        tempList = new LinkedList<>();
        
        
        this.helper(root);
        
        int sumUp = 0;
        
        for(int i=0;i<this.res.size();i++){
            int temp = 0;
            for(int j:this.res.get(i)){
                temp = temp*10+j;
            }
            sumUp+=temp;
        }
        
        return sumUp;
    }
}
```

---

### 111. Minimum Depth of Binary Tree

Given a binary tree, find its minimum depth.

The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

Note: A leaf is a node with no children.

```

Example:

Given binary tree [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
return its minimum depth = 2.
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int minDepth(TreeNode root) {
        // 最小深度指根节点到最近叶子结点的距离
        // 递归求解
        if(root == null){
            return 0;
        }
        if(root.left == null){
            return minDepth(root.right)+1;
        }
        if(root.right == null){
            return minDepth(root.left)+1;
        }
        return 1+Math.min(minDepth(root.left),minDepth(root.right));
        
    }
}
```

```
Runtime: 0 ms, faster than 100.00% of Java online submissions for Minimum Depth of Binary Tree.
Memory Usage: 41.2 MB, less than 18.81% of Java online submissions for Minimum Depth of Binary Tree.
```

### 104. Maximum Depth of Binary Tree

Given a binary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

Note: A leaf is a node with no children.

```
Example:

Given binary tree [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
return its depth = 3.

```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        // 最大深度指根节点到最远叶子结点的距离
        // 递归求解
        if(root == null){
            return 0;
        }
        if(root.left == null){
            return maxDepth(root.right)+1;
        }
        if(root.right == null){
            return maxDepth(root.left)+1;
        }
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

```
Runtime: 0 ms, faster than 100.00% of Java online submissions for Maximum Depth of Binary Tree.
Memory Usage: 40.5 MB, less than 20.13% of Java online submissions for Maximum Depth of Binary Tree.
```

### 662. Maximum Width of Binary Tree

Given a binary tree, write a function to get the maximum width of the given tree. The maximum width of a tree is the maximum width among all levels.

The width of one level is defined as the length between the end-nodes (the leftmost and right most non-null nodes in the level, where the null nodes between the end-nodes are also counted into the length calculation.

It is guaranteed that the answer will in the range of 32-bit signed integer.
```
Example 1:

Input: 

           1
         /   \
        3     2
       / \     \  
      5   3     9 

Output: 4
Explanation: The maximum width existing in the third level with the length 4 (5,3,null,9).
Example 2:

Input: 

          1
         /  
        3    
       / \       
      5   3     

Output: 2
Explanation: The maximum width existing in the third level with the length 2 (5,3).
Example 3:

Input: 

          1
         / \
        3   2 
       /        
      5      

Output: 2
Explanation: The maximum width existing in the second level with the length 2 (3,2).
Example 4:

Input: 

          1
         / \
        3   2
       /     \  
      5       9 
     /         \
    6           7
Output: 8
Explanation:The maximum width existing in the fourth level with the length 8 (6,null,null,null,null,null,null,7).
 

Constraints:

The given binary tree will have between 1 and 3000 nodes.
```

```java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    class Pair{
        TreeNode node;
        int index;

        Pair(TreeNode node,int index){
            this.node = node;
            this.index = index;
        }

    }
    public int widthOfBinaryTree(TreeNode root) {
        // 做法是层次遍历 + 完全二叉树的节点位置性质
        // 这个性质指的是，每层都有 2 ^ (n-1)个节点。某节点的左孩子的标号是2n, 右节点的标号是2n + 1。
        // 因为这个题，中间缺少了节点的话，仍然要“认为”节点存在，所以需要使用这种标号的方法强制计算，而不是直接遍历。
        if(root==null){
            return 0;
        }
        
        
        LinkedList<Pair> level = new LinkedList<>();
        
        int width = 1;
        
        level.addLast(new Pair(root,1));
        
        while(level.size()!=0){
            int n = level.size();
            width = Math.max(width,level.getLast().index - level.getFirst().index+1);
            
            for(int i=0;i<n;i++){
                Pair currentNode = level.removeFirst();
                if(currentNode.node.left!=null){
                    level.addLast(new Pair(currentNode.node.left,currentNode.index*2));
                }
                if(currentNode.node.right!=null){
                    level.addLast(new Pair(currentNode.node.right,currentNode.index*2+1));
                }
            }
        }
        
        return width;
    }
}
```

```
Runtime: 1 ms, faster than 92.52% of Java online submissions for Maximum Width of Binary Tree.
Memory Usage: 38.1 MB, less than 100.00% of Java online submissions for Maximum Width of Binary Tree.
```

### 559. Maximum Depth of N-ary Tree

Given a n-ary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).

![](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)

```
Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
Output: 5
```

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
    public int maxDepth(Node root) {
        if(root==null){
            return 0;
        }Q
        if(root.children.size()==0){
            return 1;
        }
        int res =0;
        for(Node child: root.children){
            res = Math.max(res,maxDepth(child));
        }
        
        return res+1;
    }
}
```

## Binary search

* 278 First Bad Version e
  * 二分查找
    ```
    Runtime: 14 ms, faster than 29.55% of Java online submissions for First Bad Version.
    Memory Usage: 35.9 MB, less than 80.52% of Java online submissions for First Bad Version.
    ```
* 35 Search Insert Position e
  * 二分查找
    ```
    Runtime: 0 ms, faster than 100.00% of Java online submissions for Search Insert Position.
    Memory Usage: 41.2 MB, less than 5.06% of Java online submissions for Search Insert Position.
    ```
* 33 Search in Rotated Sorted Array m
  * 魔改版二分查找
    ```
    Runtime: 0 ms, faster than 100.00% of Java online submissions for Search in Rotated Sorted Array.
    Memory Usage: 39.3 MB, less than 37.54% of Java online submissions for Search in Rotated Sorted Array.
    ```
* 81 Search in Rotated Sorted Array II m
  * 可以用二分查找，但是有点复杂，试着直接一遍遍历，结果还挺好
    ```
    Runtime: 0 ms, faster than 100.00% of Java online submissions for Search in Rotated Sorted Array II.
    Memory Usage: 39.4 MB, less than 35.34% of Java online submissions for Search in Rotated Sorted Array II.
    ```
* 153 Find Minimum in Rotated Sorted Array m
  * 直接一遍遍历，结果很好
    ```
    Runtime: 0 ms, faster than 100.00% of Java online submissions for Find Minimum in Rotated Sorted Array.
    Memory Usage: 38.7 MB, less than 95.30% of Java online submissions for Find Minimum in Rotated Sorted Array.
    ```
* 154 Find Minimum in Rotated Sorted Array II h
  * 我裂开了，还是一遍遍历就行了。我怀疑他的测试用例是随机找的pivat点，所以点的分布更接近中心，平均下来可能是$N/2$，比起复杂条件的二分，直接一边遍历的开销甚至更小。
    ```
    Runtime: 0 ms, faster than 100.00% of Java online submissions for Find Minimum in Rotated Sorted Array II.
    Memory Usage: 39.5 MB, less than 36.19% of Java online submissions for Find Minimum in Rotated Sorted Array II.
    ```

### 162. Find Peak Element

A peak element is an element that is greater than its neighbors.

Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.

The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.

You may imagine that nums[-1] = nums[n] = -∞.
```
Example 1:

Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.
Example 2:

Input: nums = [1,2,1,3,5,6,4]
Output: 1 or 5 
Explanation: Your function can return either index number 1 where the peak element is 2, 
             or index number 5 where the peak element is 6.
Follow up: Your solution should be in logarithmic complexity.
```

```java
class Solution {
    public int findPeakElement(int[] nums) {
        // basecase 只有一个数字
        if (nums.length == 1) return 0;
        
        // 两边垫两个数字
        int[] newNums = new int[nums.length + 2];
        System.arraycopy(nums, 0, newNums, 1, nums.length);
        newNums[0] = Integer.MIN_VALUE;
        newNums[newNums.length - 1] = Integer.MIN_VALUE;
        
        // 一边遍历找顶峰
        for (int i = 1; i < newNums.length - 1; ++i) {
            if (newNums[i] > newNums[i - 1] && newNums[i] > newNums[i + 1]) return i - 1;
        }
        
        return -1;
    }
}
```


```
Runtime: 0 ms, faster than 100.00% of Java online submissions for Find Peak Element.
Memory Usage: 38.9 MB, less than 91.05% of Java online submissions for Find Peak Element.
```

## String

### 3 Longest Substring Without Repeating Characters M

Given a string, find the length of the longest substring without repeating characters.

Example 1:
```
Input: "abcabcbb"
Output: 3 
Explanation: The answer is "abc", with the length of 3. 
```
Example 2:
```
Input: "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
```
Example 3:
```
Input: "pwwkew"
Output: 3
```
```
Explanation: The answer is "wke", with the length of 3. 
             Note that the answer must be a substring, "pwke" is a subsequence and not a substring.
```

Solution 1

双指针思路，一个前置指针向后遍历字符，一个后置指针指向当前子串的开头。每当前置指针向后遍历一个新的字符的时候，就开始从后置指针开始遍历到前置指针-1的位置，判断是否有重复。有重复就将后指针指向子串中重复的位置，没有重复就继续遍历。

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        // 双指针
        int i =0;
        int j = 0;
        int sLen = s.length();
        int res = 0;
        
        while(i<sLen){
            // 前置指针向后遍历
            String c = s.substring(i,i+1);
            
            // 从后置指针判断是否和已有的重复
            int m =j;
            while(m<i){
                if(s.substring(m,m+1).equals(c)){
                    // 重复，重置计数并保存最大
                    res = Math.max(res,i-j);
                    // 将后置指针指向重复的位置
                    j= m+1;
                    break;
                }
                m++;
            }
            
            // 无重复，更新最长长度
            res = Math.max(res,i-j+1);
            
            i++;
        }
        
        return res;
    }
}
```

```
Runtime: 8 ms, faster than 48.91% of Java online submissions for Longest Substring Without Repeating Characters.
Memory Usage: 39.8 MB, less than 34.62% of Java online submissions for Longest Substring Without Repeating Characters.
```

* 28 Implement strStr() e
  * What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().
    ```
    Runtime: 1 ms, faster than 64.82% of Java online submissions for Implement strStr().
    Memory Usage: 39.4 MB, less than 23.61% of Java online submissions for Implement strStr().
    ```
* 14 Longest Common Prefix e
  * ```substring```
      ```
      Runtime: 3 ms, faster than 27.74% of Java online submissions for Longest Common Prefix.
      Memory Usage: 39.8 MB, less than 6.60% of Java online submissions for Longest Common Prefix.
      ```
* 58 Length of Last Word e
  * ```trim```
    ```
    Runtime: 0 ms, faster than 100.00% of Java online submissions for Length of Last Word.
    Memory Usage: 37.5 MB, less than 74.80% of Java online submissions for Length of Last Word.
    ```
* 387 First Unique Character in a String e
  * Can be optimized
    ```
    Runtime: 37 ms, faster than 10.01% of Java online submissions for First Unique Character in a String.
    Memory Usage: 39.6 MB, less than 87.99% of Java online submissions for First Unique Character in a String.
    ```
* 383 Ransom Note e
  * ```HashMap, toCharArray```
    ```
    Runtime: 9 ms, faster than 46.81% of Java online submissions for Ransom Note.
    Memory Usage: 40.8 MB, less than 17.90% of Java online submissions for Ransom Note.
    ```
* 344 Reverse String e
  * Nothing to optimized
    ```
    Runtime: 1 ms, faster than 56.87% of Java online submissions for Reverse String.
    Memory Usage: 46.2 MB, less than 58.97% of Java online submissions for Reverse String.
    ```

## Math

* 7 Reverse Integer e
  * ```Math.pow```, ```Integer.MAX_VALUE```
    ```
    Runtime: 1 ms, faster than 100.00% of Java online submissions for Reverse Integer.
    Memory Usage: 36.6 MB, less than 76.60% of Java online submissions for Reverse Integer.
    ```
* 165 Compare Version Numbers m
  * ```str.split()```, ```\\.```, ```Integer.parseInt()```,```()? : ```
    ```
    Runtime: 1 ms, faster than 90.04% of Java online submissions for Compare Version Numbers.
    Memory Usage: 37.6 MB, less than 39.17% of Java online submissions for Compare Version Numbers.
    ```
* 66 Plus One e
  * Nothing to say
    ```
    Runtime: 0 ms, faster than 100.00% of Java online submissions for Plus One.
    Memory Usage: 38.3 MB, less than 19.00% of Java online submissions for Plus One.
    ```
* 8 String to Integer (atoi) m
  * ```StringBuilder```
    ```
    Runtime: 4 ms, faster than 25.51% of Java online submissions for String to Integer (atoi).
    Memory Usage: 40.5 MB, less than 6.15% of Java online submissions for String to Integer (atoi).
    ```
* 258 Add Digits
  * Nothing to say
    ```
    Runtime: 1 ms, faster than 100.00% of Java online submissions for Add Digits.
    Memory Usage: 36.9 MB, less than 47.08% of Java online submissions for Add Digits.
    ```
* 67 Add Binary
  * ```Integer.toBinaryString```, ```Integer.parseInt(str,radix)```, ```StringBuilder```, ```StringBuilder.reverse().toString()```
    ```
    Runtime: 2 ms, faster than 76.96% of Java online submissions for Add Binary.
    Memory Usage: 37.9 MB, less than 90.16% of Java online submissions for Add Binary.
    ```

### 15. 3Sum M

Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

Note:

The solution set must not contain duplicate triplets.

Example:
```
Given array nums = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

Solution 1

整体思路就是先排序，然后对于每一对计算其相反数，然后用二分查找寻找解，需要注意避免重复的条件

```java

class Solution {
    static public int binarySearch(int[] nums,int lo,int hi,int target){
        while(lo<=hi){
            int mid = lo+(hi-lo)/2;
            if(nums[mid]==target){
                System.out.println(mid);
                return mid;
            }
            if(target>nums[mid]){
                lo = mid+1;
            }else if(target<nums[mid]){
                hi = mid-1;
            }
        }
        return -1;
    }
    static public List<List<Integer>> threeSum(int[] nums) {
        if(nums==null){
            return null;
        }
        // 初始化结果
        List<List<Integer>> res = new ArrayList<>();
        // 先将原数组排序
        Arrays.sort(nums);

        // 对于每一对 nums[i] 和 nums[j] 二分查找 对应的 nums[m] = -(nums[i]+nums[j])
        for(int i =0;i<nums.length-2;i++){
                if(i>0&&nums[i]==nums[i-1]){
                    continue;
                }
            for(int j=nums.length-1;j>i+1;j--){

                
                if(j<nums.length-1&&nums[j+1]==nums[j]){
                    continue;
                }
                // 二分查找
                int lo = i+1;
                int hi =j-1;
                int target = 0-nums[i]-nums[j];
                int m = binarySearch(nums,lo,hi,target);

                if(m!=-1){
                    // 存在一个解
                    res.add(Arrays.asList(nums[i],nums[j],nums[m]));
                }

            }
        }

        return res;
    }
}
```

```
Runtime: 358 ms, faster than 20.77% of Java online submissions for 3Sum.
Memory Usage: 43.4 MB, less than 63.13% of Java online submissions for 3Sum.
```

## Array

### 27. Remove Element E

Given an array nums and a value val, remove all instances of that value in-place and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

The order of elements can be changed. It doesn't matter what you leave beyond the new length.

```
Given nums = [3,2,2,3], val = 3,

Your function should return length = 2, with the first two elements of nums being 2.

It doesn't matter what you leave beyond the returned length.
```

```
Given nums = [0,1,2,2,3,0,4,2], val = 2,

Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.

Note that the order of those five elements can be arbitrary.

It doesn't matter what values are set beyond the returned length.
```

思路很简单，从尾部开始遍历

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int tail = 0;
        for (int current : nums) {
            if (current != val) {
                nums[tail++] = current;
            }
        }
        return tail;
    }
}
```

```
Runtime: 0 ms, faster than 100.00% of Java online submissions for Remove Element.
Memory Usage: 40 MB, less than 5.06% of Java online submissions for Remove Element.
```

### 26. Remove Duplicates from Sorted Array E

Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

Example 1:
```
Given nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.

It doesn't matter what you leave beyond the returned length.
```
Example 2:
```
Given nums = [0,0,1,1,1,2,2,3,3,4],

Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.

It doesn't matter what values are set beyond the returned length.
```

思路是用双指针，一个指针遍历数组，另一个指针每当有不同元素的时候就后移一位，并把不同的那个元素放过来

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int j = 0;
        for(int i=0;i<nums.length;i++){
            if(nums[j]!=nums[i]){
                nums[++j] = nums[i];
            }
        }
        return j+1;
    }
}
```

```
Runtime: 0 ms, faster than 100.00% of Java online submissions for Remove Duplicates from Sorted Array.
Memory Usage: 41.3 MB, less than 55.16% of Java online submissions for Remove Duplicates from Sorted Array.
```

### 80. Remove Duplicates from Sorted Array II M

Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

Example 1:
```
Given nums = [1,1,1,2,2,3],

Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.

It doesn't matter what you leave beyond the returned length.
```
Example 2:
```
Given nums = [0,0,1,1,1,1,2,3,3],

Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.

It doesn't matter what values are set beyond the returned length.
```

因为数组是sorted，可以如下考虑，使用一个指针，将原先数组的元素依次放入按顺序排的位置，但是最多同一个元素不能超过两个

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length < 3){
            return nums.length;
        }
        int count= 0;
        int tempCount = 0;
        for(int i=count+1;i<nums.length;i++){
            if(nums[count]==nums[i])
                tempCount++;
            
            if(nums[count]==nums[i] && tempCount<2){
                nums[++count] =nums[i];
            }else if(nums[count]!=nums[i] ){
                tempCount=0;
                nums[++count] =nums[i];

            }
        }
        return count+1;
    }
}
```

```
Runtime: 0 ms, faster than 100.00% of Java online submissions for Remove Duplicates from Sorted Array II.
Memory Usage: 39.6 MB, less than 59.90% of Java online submissions for Remove Duplicates from Sorted Array II.
```

### 189. Rotate Array

Given an array, rotate the array to the right by k steps, where k is non-negative.

Follow up:

Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.

Could you do it in-place with O(1) extra space?
 

Example 1:
```
Input: nums = [1,2,3,4,5,6,7], k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]
```
Example 2:
```
Input: nums = [-1,-100,3,99], k = 2
Output: [3,99,-1,-100]
Explanation: 
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]
```

Solution 1: in-place with O(1) extra space

很简单就是将数组向后旋转k次

```java
class Solution {
    public void rotate(int[] nums, int k) {
        while(k>0){
            int last = nums[nums.length-1];
            for(int i =nums.length-1;i>0;i--){
                nums[i] = nums[i-1];
            }
            nums[0] = last;
            k--;
        }
        
    }
}
```

```
Runtime: 248 ms, faster than 5.63% of Java online submissions for Rotate Array.
Memory Usage: 39.5 MB, less than 98.82% of Java online submissions for Rotate Array.
```

Solution 2: in-place with O(1) extra space

思路也是翻转，但是快很多。先将数组整体翻转，然后用k将数组分为两部分，两部分分别翻转即可。这里要注意k，需要对数组长度取余，防止越界

```java
class Solution {
    private void reverse(int[] nums, int i,int j){
            while(i<j){
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
                i++;
                j--;
            }
    }
    public void rotate(int[] nums, int k) {
        k = k%nums.length;
        reverse(nums,0,nums.length-1);
        reverse(nums,0,k-1);
        reverse(nums,k,nums.length-1);
        
    }
}
```

```
Runtime: 0 ms, faster than 100.00% of Java online submissions for Rotate Array.
Memory Usage: 40 MB, less than 64.98% of Java online submissions for Rotate Array.
```

### 41. First Missing Positive H

Given an unsorted integer array, find the smallest missing positive integer.

Example 1:
```
Input: [1,2,0]
Output: 3
```
Example 2:
```
Input: [3,4,-1,1]
Output: 2
```
Example 3:
```
Input: [7,8,9,11,12]
Output: 1
```

Note:

Your algorithm should run in O(n) time and uses constant extra space.

思路就是把数字放到对应下标的位置，然后从头遍历一遍看第一个不对应的地方

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        if(nums.length==0) return 1;
        for(int i=0;i<nums.length;i++){
            while(nums[i]!=i+1&&nums[i]<nums.length&&nums[i]>0&&nums[i]!=nums[nums[i]-1]){
                int temp = nums[nums[i]-1];
                nums[nums[i]-1] = nums[i]; 
                nums[i] = temp;
            }
        }
        
        for(int i=0;i<nums.length;i++){
            if(nums[i]!=i+1){
                return i+1;
            }
        }
        return nums.length+1;
    }
}
```

```
Runtime: 24 ms, faster than 5.26% of Java online submissions for First Missing Positive.
Memory Usage: 40 MB, less than 5.07% of Java online submissions for First Missing Positive.
```

### 134. Gas Station M

There are N gas stations along a circular route, where the amount of gas at station i is gas[i].

You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.

Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1.

Note:

* If there exists a solution, it is guaranteed to be unique.
* Both input arrays are non-empty and have the same length.
* Each element in the input arrays is a non-negative integer.

Example 1:
```
Input: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

Output: 3

Explanation:
Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 4. Your tank = 4 - 1 + 5 = 8
Travel to station 0. Your tank = 8 - 2 + 1 = 7
Travel to station 1. Your tank = 7 - 3 + 2 = 6
Travel to station 2. Your tank = 6 - 4 + 3 = 5
Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.
Therefore, return 3 as the starting index.
```
Example 2:
```
Input: 
gas  = [2,3,4]
cost = [3,4,3]

Output: -1

Explanation:
You can't start at station 0 or 1, as there is not enough gas to travel to the next station.
Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 0. Your tank = 4 - 3 + 2 = 3
Travel to station 1. Your tank = 3 - 3 + 3 = 3
You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.
Therefore, you can't travel around the circuit once no matter where you start.
```

Solution 1: 直观上的方法就是遍历每个点，并将其作为起点，循环一边看有还有没有剩下

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int tank = 0;
        for(int i=0;i<gas.length;i++){
            tank += gas[i]-cost[i];
        }
        if(tank<0) return -1;
        
        for(int i=0;i<gas.length;i++){
            tank = 0;
            for(int j = i;j<i+gas.length;j++){
                tank+=gas[j%gas.length];
                tank-=cost[j%gas.length];
                if(tank<0)
                    break;
            }
            if(tank>=0){
                return i;
            }
        }
        
        return -1;
    }
}
```

Solution 2: 贪心算法，这个问题的核心是gas的和一定要比cost大才能走一圈，所以前面任意gas比cost小的情况，都会被考虑到后面gas大于cost的里面

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int tank = 0;
        for(int i=0;i<gas.length;i++){
            tank += gas[i]-cost[i];
        }
        if(tank<0) return -1;
        
        int start = 0;
        int remain = 0;
        for(int i=0;i<gas.length;i++){
            if(gas[i]+remain < cost[i]){
                start = i+1;
                remain = 0;
            }else{
                remain += gas[i]-cost[i];
            }
        }
        return start;
    }
}
```

```
Runtime: 0 ms, faster than 100.00% of Java online submissions for Gas Station.
Memory Usage: 40.1 MB, less than 24.14% of Java online submissions for Gas Station.
```

### 146. LRU Cache

Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.

get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.

The cache is initialized with a positive capacity.

Follow up:
Could you do both operations in O(1) time complexity?

Example:
```
LRUCache cache = new LRUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.put(4, 4);    // evicts key 1
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4
```

Solution 1 HashMap 和 LinkedList

```java
class LRUCache {
    
    private int capacity;
    private HashMap cache;
    private LinkedList order;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.cache = new HashMap();
        this.order = new LinkedList();
    }
    
    public int get(int key) {
        if(this.cache.containsKey(key)){
            this.order.remove(new Integer(key));
            this.order.addFirst(new Integer(key));
            return (int)this.cache.get(key);
        }
        return -1;
    }
    
    public void put(int key, int value) {
        Object k = this.cache.get(key);
        if(k!=null){
            // 存在
            this.order.remove(new Integer(key));
            this.order.addFirst(new Integer(key));
            this.cache.put(key,value); // 覆盖更新
        }else{
            this.order.addFirst(new Integer(key));
            this.cache.put(key,value);
        }
        if(this.cache.size()>this.capacity){
            // 超出容量限制
            this.cache.remove((int)this.order.removeLast());
        }
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

[引申 - 三种方法手撕LRU算法](https://leetcode-cn.com/problems/lru-cache/solution/san-chong-fang-fa-dai-ni-shou-si-lrusuan-fa-javaba/)

### 78. Subsets

Given a set of distinct integers, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

```
Example:

Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```

### 118. Pascal's Triangle

Given a non-negative integer numRows, generate the first numRows of Pascal's triangle.

![](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)

In Pascal's triangle, each number is the sum of the two numbers directly above it.

```
Example:

Input: 5
Output:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
```

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> res = new ArrayList<>();
        if(numRows==0){
            return res;
        }
        res.add(new ArrayList<>(Arrays.asList(1)));        
        for(int i=2;i<=numRows;i++){
            List<Integer> temp = new ArrayList<>();
            List<Integer> pre = res.get(i-2);
            temp.add(1);
            for(int j=2;j<i;j++){
                temp.add(pre.get(j-2)+pre.get(j-1));
            }
            temp.add(1);
            res.add(temp);
        }
        return res;
    }
}
```

```
Runtime: 0 ms, faster than 100.00% of Java online submissions for Pascal's Triangle.
Memory Usage: 37.2 MB, less than 55.03% of Java online submissions for Pascal's Triangle.
```

### 119. Pascal's Triangle II

Given an integer rowIndex, return the rowIndexth row of the Pascal's triangle.

Notice that the row index starts from 0.

![](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)

In Pascal's triangle, each number is the sum of the two numbers directly above it.

Follow up:

Could you optimize your algorithm to use only O(k) extra space?

```
Example 1:

Input: rowIndex = 3
Output: [1,3,3,1]
Example 2:

Input: rowIndex = 0
Output: [1]
Example 3:

Input: rowIndex = 1
Output: [1,1]
 

Constraints:

0 <= rowIndex <= 40
```

```java
class Solution {
    public List<Integer> getRow(int rowIndex) {
        List<Integer> row = new ArrayList<>(rowIndex);
        row.add(1);
        int prev = row.get(0);
        for (int i = 1; i <= rowIndex; i++) {
            for (int j = 0; j < i - 1; j++) {
                prev = row.set(j + 1, row.get(j + 1) + prev);
            }
            row.add(1);
        }
        return row;
    }
}
```

```
Runtime: 2 ms, faster than 11.30% of Java online submissions for Pascal's Triangle II.
Memory Usage: 38.4 MB, less than 10.25% of Java online submissions for Pascal's Triangle II.
```

### 169. Majority Element

Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.

You may assume that the array is non-empty and the majority element always exist in the array.

```
Example 1:

Input: [3,2,3]
Output: 3
Example 2:

Input: [2,2,1,1,1,2,2]
Output: 2
```

```java
class Solution {
    public int majorityElement(int[] nums) {
        // 摩尔投票法
        // 因为已知一定有超过 n/2 的数字
        // 遍历一遍，出现相同 count ++ 不同 count--，count = 0 的时候 res 为当前的数字，最后res即为要求的数字
        // 时间复杂度为O(n)，空间复杂度为O(1)
        
        int res = nums[0];
        int count = 0;
        
        for(int i:nums){
            if(count==0){
                count=1;
                res = i;
            }else if(res==i){
                count++;
            }else{
                count--;
            }
        }
        return res;
    }
}
```

```
Runtime: 1 ms, faster than 99.93% of Java online submissions for Majority Element.
Memory Usage: 42.3 MB, less than 87.67% of Java online submissions for Majority Element.
```

### 179. Largest Number

Given a list of non negative integers, arrange them such that they form the largest number.
```
Example 1:

Input: [10,2]
Output: "210"
Example 2:

Input: [3,30,34,5,9]
Output: "9534330"
Note: The result may be very large, so you need to return a string instead of an integer.
```

```java
class Solution {
    public String largestNumber(int[] nums) {
        // 这种解法对于两个数字a和b来说，如果将其都转为字符串，如果 ab > ba，则a排在前面，
        // 比如9和34，由于 934>349，所以9排在前面，再比如说 30 和3，由于 303<330，所以3排在 30 的前面。
        // 按照这种规则对原数组进行排序后，将每个数字转化为字符串再连接起来就是最终结果
        String[] numsC = new String[nums.length];
        for(int i=0;i<nums.length;i++){
            numsC[i] = String.valueOf(nums[i]);
        }
        Arrays.sort(numsC,(a,b)-> (b+a).compareTo(a+b));
        
        if(numsC[0].equals("0")){
            return "0";
        }
        
        StringBuilder sb = new StringBuilder();
        
        for(String c:numsC){
            sb.append(c);
        }
        
        return sb.toString();
    }
}
```

```java
Runtime: 4 ms, faster than 97.36% of Java online submissions for Largest Number.
Memory Usage: 38.4 MB, less than 94.21% of Java online submissions for Largest Number.
```

### 229. Majority Element II

Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.

Follow-up: Could you solve the problem in linear time and in O(1) space?

```

Example 1:

Input: nums = [3,2,3]
Output: [3]
Example 2:

Input: nums = [1]
Output: [1]
Example 3:

Input: nums = [1,2]
Output: [1,2]
 

Constraints:

1 <= nums.length <= 5 * 104
-109 <= nums[i] <= 109

```

```java
class Solution {
    public List<Integer> majorityElement(int[] nums) {
        // 摩尔投票法
        // 每次删除三个不相同的数，最后留下的一定是出现次数超过1/3的数，这个思想可以推广到出现次数超过1/k次的元素有哪些
        
        // 因为出现次数大于n/3的元素最多只有两个，所以最开始可以维护两个数字(num1,num2)和两个计数器(counter1,counter2)；
        // 遍历数组，当数组中元素和num1或者num2相同，对应的counter1或者counter2加1；
        // 如果counter1或counter2为0，将遍历到的该元素赋给num1或者nums2；
        // 否则counter1和counter2都减1。

        int counter1=0,counter2=0;
        int nums1 = 0;
        int nums2 = 0;
        for(int i:nums){
            if(nums1==(i)){
                counter1++;
            }else if(nums2==(i)){
                counter2++;
            }else if(counter1==0){
                counter1++;
                nums1 = i;
            }else if(counter2==0){
                counter2++;
                nums2 = i; 
            }else{
                counter1--;
                counter2--;
            }
        }
        
        counter1=0;
        counter2=0;
        
        for(int i:nums){
            if(nums1==(i)){
                counter1++;
            }else if(nums2==(i)){
                counter2++;
            }
        }
        
        List<Integer> res =new ArrayList<>();
        if(counter1>nums.length/3){
            res.add(nums1);

        }
        if(counter2>nums.length/3){
            res.add(nums2);

        }
        return res;
    }
}
```

```
Runtime: 1 ms, faster than 99.95% of Java online submissions for Majority Element II.
Memory Usage: 43 MB, less than 8.34% of Java online submissions for Majority Element II.
```

## Bit Manipulation

### 389. Find the Difference E

Given two strings s and t which consist of only lowercase letters.

String t is generated by random shuffling string s and then add one more letter at a random position.

Find the letter that was added in t.

Example:
```
Input:
s = "abcd"
t = "abcde"

Output:
e

Explanation:
'e' is the letter that was added.
```

Solution 1:

思路：先排序然后按位查询，因为Arrays.sort针对基本数据类型的实现是quicksort，所以时间复杂度是$O(N\log N)$

```java
class Solution {
    public char findTheDifference(String s, String t) {
        char[] sS = s.toCharArray();
        char[] tT = t.toCharArray();
        
        Arrays.sort(sS);
        Arrays.sort(tT);
        
        for(int i=0;i<tT.length;i++){
            if(i>sS.length-1){
                return tT[i];
            }
            else if(tT[i]!=sS[i]){
                return tT[i];
            }
        }
        
        return ' ';
    }
}
```

```
Runtime: 6 ms, faster than 25.86% of Java online submissions for Find the Difference.
Memory Usage: 39.8 MB, less than 5.03% of Java online submissions for Find the Difference.
```

Solution 2 位运算，利用异或的性质来得到新添加的字符

```java
class Solution {
    public char findTheDifference(String s, String t) {
        char[] sS = s.toCharArray();
        char[] tT = t.toCharArray();
        char res = 0;
        for(int i=0;i<tT.length;i++){
            if(i>sS.length-1){
                res ^= tT[i];
            }else{
                res ^= tT[i];
                res ^= sS[i];
            }
        }
        return res;
    }
}
```

```
Runtime: 2 ms, faster than 56.20% of Java online submissions for Find the Difference.
Memory Usage: 40.1 MB, less than 5.03% of Java online submissions for Find the Difference.
```

### 136. Single Number E

Given a non-empty array of integers, every element appears twice except for one. Find that single one.

Note:

Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?

Example 1:
```
Input: [2,2,1]
Output: 1
```
Example 2:
```
Input: [4,1,2,1,2]
Output: 4
```

这个就非常明显了，直接用位运算异或即可

```java
class Solution {
    public int singleNumber(int[] nums) {
        int res=0;
        for(int i=0;i<nums.length;i++){
            res ^= nums[i];
        }
        return res;
    }
}
```

```
Runtime: 1 ms, faster than 63.74% of Java online submissions for Single Number.
Memory Usage: 44.2 MB, less than 6.16% of Java online submissions for Single Number.
```

### 137. Single Number II M

Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one.

Note:

Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?

Example 1:
```
Input: [2,2,3,2]
Output: 3
```
Example 2:
```
Input: [0,1,0,1,0,1,99]
Output: 99
```

遍历位数，如果所有数字在这位上的总和不是3的倍数，那么单次出现的数字在这一位一定有值，逐位拼凑出来这个数字 

```java
class Solution {
    public int singleNumber(int[] nums) {
        int res=0;
        for(int i=0;i<32;i++){
            int count = 0;
            for(int j:nums){
                if((j>>i & 1)==1){
                    count++;
                }
            }
            if(count%3!=0){
                res |= 1 << i;
            }
        }
        return res;
    }
}
```
```
Runtime: 3 ms, faster than 57.22% of Java online submissions for Single Number II.
Memory Usage: 39.3 MB, less than 50.72% of Java online submissions for Single Number II.
```

## Dynamic Programming 

### 322. Coin Change

You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

Example 1:
```
Input: coins = [1, 2, 5], amount = 11
Output: 3 
Explanation: 11 = 5 + 5 + 1
```
Example 2:
```
Input: coins = [2], amount = 3
Output: -1
```

Note:
You may assume that you have an infinite number of each kind of coin.

Solution 1

使用动态规划的思想，自底向上，添加一个记忆空间用来记忆已计算的结果，加速计算

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount+1];
        Arrays.fill(dp,amount+1);
        
        // base case
        dp[0] = 0;
        for (int i = 0; i < dp.length; i++) {
            // 内层 for 在求所有子问题 + 1 的最小值
            for (int coin : coins) {
                // 子问题无解，跳过
                if (i - coin < 0) continue;
                dp[i] = Math.min(dp[i], 1 + dp[i - coin]);
            }
        }
        return (dp[amount] == amount + 1) ? -1 : dp[amount];
    }
}
```

```
Runtime: 10 ms, faster than 95.20% of Java online submissions for Coin Change.
Memory Usage: 39 MB, less than 72.68% of Java online submissions for Coin Change.
```

### 300. Longest Increasing Subsequence M

Given an unsorted array of integers, find the length of longest increasing subsequence.

Example:
```
Input: [10,9,2,5,3,7,101,18]
Output: 4 
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. 
```
Note:

There may be more than one LIS combination, it is only necessary for you to return the length.
Your algorithm should run in O(n2) complexity.

Solution 1

思路就是动态规划，自顶向下求解问题

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        // 直观上去看，nums的最长递增子序列取决于以某个元素 A 结尾的递增序列长度，并且该序列的长度取决于“A 大于的上一个元素结尾的递增序列的最长长度”
        // “A 大于的上一个元素结尾的递增序列” 可以包含 A 元素，这样就会原来序列的基础上+1
        // 若不包含，考虑 以A 本身结尾的递增序列  和 其他序列的长度哪个大
        
        // 新状态取决于旧状态，动规开始
        
        // 状态定义
        // dp[i] 为以 nums[i] 结尾的最长递增子序列的个数

        int[] dp = new int[nums.length];
        
        // basecase 就是至少要包含 nums[i] 这个数字，长度至少为 1
        Arrays.fill(dp,1);
        
        // 状态转移
        for(int i=0;i<nums.length;i++){
            for(int j=0;j<i;j++){
                if(nums[i]>nums[j]){
                    // 原来的递增序列包不包含 nums[i]
                    dp[i] = Math.max(dp[j]+1,dp[i]);
                }
            }
        }
        
        // 遍历子状态集返回最大的长度
        int res = 0;
        for(int temp : dp){
            res = Math.max(res,temp);
        }
        return res;
    }
}
```

```
Runtime: 11 ms, faster than 62.23% of Java online submissions for Longest Increasing Subsequence.
Memory Usage: 37.3 MB, less than 85.70% of Java online submissions for Longest Increasing Subsequence.
```

### 53. Maximum Subarray E

Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

Example:
```
Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
```

Follow up:

If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.

Solution 1

自顶向下动态规划


```java
class Solution {
    private int[] dp;
    public int maxSubArray(int[] nums) {
        // 动态规划初始化
        // 状态为： dp[i] 是以 nums[i] 结尾的数组中，最大的和，
        dp = new int[nums.length];
        // 最前面的dp没有更前的字数组
        dp[0] = nums[0];
        
        // 自顶向下解决问题
        for(int i=1;i<nums.length;i++){
            dp[i] = Math.max(nums[i],nums[i]+dp[i-1]); 
        }
        
        // 遍历状态集，寻找最大
        int res = Integer.MIN_VALUE;
        for(int item:dp){
            res = Math.max(res,item);
        }
        return res;
        
    }
}
```

```
Runtime: 1 ms, faster than 75.96% of Java online submissions for Maximum Subarray.
Memory Usage: 41.5 MB, less than 9.09% of Java online submissions for Maximum Subarray.
```

### 518. Coin Change 2 M

You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.

 

Example 1:
```
Input: amount = 5, coins = [1, 2, 5]
Output: 4
Explanation: there are four ways to make up the amount:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

Example 2:
```
Input: amount = 3, coins = [2]
Output: 0
Explanation: the amount of 3 cannot be made up just with coins of 2.
```

Example 3:
```
Input: amount = 10, coins = [10] 
Output: 1
```

Note:

You can assume that
```
0 <= amount <= 5000
1 <= coin <= 5000
the number of coins is less than 500
the answer is guaranteed to fit into signed 32-bit integer
```

Solution 1

完全背包问题，自顶向下动态规划。不压缩状态

```java

class Solution {
    public int change(int amount, int[] coins) {
        // 处理输入边界条件
        if(amount == 0){
            return 1;
        }
        if(coins.length == 0){
            return 0;
        }
        // 完全背包问题
        // 考虑状态，有两个，一个是使用了前几种面值的硬币，一个是当前要凑的总额
        // dp[i][j] 表示为，在使用前i种面额的硬币凑 j 的方法数量
        int[][] dp = new int[coins.length+1][amount+1];
        
        // base case是，i=0的时候，意味着没有面额给是使用，所以dp[0][:]=0
        // j=0的时候，不论用那种面额，都只有一种结果，所以
        for(int i=1;i<coins.length+1;i++){
            dp[i][0] = 1;
        }
        
        // 动态规划，自顶向下
        // 有两种前置 一种是使用前i种面额凑钱，一种是使用前i-1种凑钱，但因为是可能性的总数，所以要相加
        for(int i=1;i<coins.length+1;i++){
            // 因为定义的i比coins实际对应面额的下标小1，所以减1
            for(int j=1;j<amount+1;j++){
                // 防止越界
                if(j - coins[i-1]>=0){
                    dp[i][j] = dp[i-1][j]+dp[i][j-coins[i-1]];  
                }else{
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        
        
        // 返回结果
        return dp[coins.length][amount];
       
    }
}
```

```
Runtime: 23 ms, faster than 11.28% of Java online submissions for Coin Change 2.
Memory Usage: 48.5 MB, less than 6.51% of Java online submissions for Coin Change 2.
```

Solution 2

状态压缩，因为dp[i] 只和 dp[i-1] 有关，故可以压缩状态，减少空间复杂度


```java
class Solution {
    // private int[][] dp;
    private int[] dp;
    
    public int change(int amount, int[] coins) {
        // 处理输入边界条件
        if(amount == 0){
            return 1;
        }
        if(coins.length == 0){
            return 0;
        }
        // 完全背包问题
        // 考虑状态，有两个，一个是使用了前几种面值的硬币，一个是当前要凑的总额
        // dp[i][j] 表示为，在使用前i种面额的硬币凑 j 的方法数量
        // dp = new int[coins.length+1][amount+1];
        dp = new int[amount+1];
        
        // base case是，i=0的时候，意味着没有面额给是使用，所以dp[0][:]=0
        // j=0的时候，不论用那种面额，都只有一种结果，所以
        // for(int i=1;i<coins.length+1;i++){
        //     dp[i][0] = 1;
        // }
        dp[0]=1;
        
        // 动态规划，自顶向下
        // 有两种前置 一种是使用前i种面额凑钱，一种是使用前i-1种凑钱，但因为是可能性的总数，所以要相加
        // for(int i=1;i<coins.length+1;i++){
        //     // 因为定义的i比coins实际对应面额的下标小1，所以减1
        //     for(int j=1;j<amount+1;j++){
        //         // 防止越界
        //         if(j - coins[i-1]>=0){
        //             dp[i][j] = dp[i-1][j]+dp[i][j-coins[i-1]];  
        //         }else{
        //             dp[i][j] = dp[i-1][j];
        //         }
        //     }
        // }
        for(int i=0;i<coins.length;i++){
            // 因为定义的i比coins实际对应面额的下标小1，所以减1
            for(int j=1;j<amount+1;j++){
                // 防止越界
                if(j - coins[i]>=0){
                    dp[j] = dp[j]+dp[j-coins[i]];  
                }
            }
        }
        
        
        // 返回结果
        return dp[amount];
    }
}
```

```
Runtime: 4 ms, faster than 54.50% of Java online submissions for Coin Change 2.
Memory Usage: 36.9 MB, less than 75.83% of Java online submissions for Coin Change 2.
```

### 416. Partition Equal Subset Sum M

Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.

Note:
```
Each of the array element will not exceed 100.
The array size will not exceed 200.
```

Example 1:
```
Input: [1, 5, 11, 5]

Output: true

Explanation: The array can be partitioned as [1, 5, 5] and [11].
```
 

Example 2:
```
Input: [1, 2, 3, 5]

Output: false

Explanation: The array cannot be partitioned into equal sum subsets.
```

Solution 

```java
class Solution {
    public boolean canPartition(int[] nums) {
        // 背包问题
        // 抽象为：用一个背包，容量为 sum(nums)/2 ，物品重量为 nums ，是否能恰好装满
        
        // 计算 sum
        int sum = 0;
        for(int i:nums)
            sum+=i;
        
        // 基本判断
        if(sum%2!=0)
            // sum为奇数，不可能划分成两个相等的子集
            return false;
        
        if(nums.length==0)
            // 没有数字可以用来凑
            return false;
        
//         // 状态定义 dp[i][j] 代表 容量为 j 的时候，用前 i 个数字是否能恰好装满
//         boolean[][] dp = new boolean[nums.length+1][sum/2+1];
        
//         // basecase 
//         // 当 j 为 0 的时候，不用装就是已满
//         // 当 i 为 0 的时候，除了 j 为 0 ，其他情况一定装不满
//         for(int i=0;i<=nums.length;i++){
//             dp[i][0] = true;
//         }
        
//         // 状态转移
//         for(int i=1;i<=nums.length;i++){
//             for(int j=sum/2;j>=0;j--){
//                 if(j-nums[i-1]<0){
//                     // 容量不足
//                     dp[i][j] = dp[i-1][j];
//                 }else{
//                     // 不装入或者装入
//                     dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i-1]];
//                 }
//             }
//         }
        
//         return dp[nums.length][sum/2];
        
        // 空间压缩
        // 注意到 dp[i][j] 都是通过上一行 dp[i-1][..] 转移过来的，之前的数据都不会再使用了
        
        // 状态定义 dp[i][j] 代表 容量为 j 的时候，用前 i 个数字是否能恰好装满
        boolean[] dp = new boolean[sum/2+1];
        
        // basecase 
        // 当 j 为 0 的时候，不用装就是已满
        // 当 i 为 0 的时候，除了 j 为 0 ，其他情况一定装不满
        
        dp[0] = true;
        
        
        // 状态转移
        for(int i=1;i<=nums.length;i++){
            for(int j=sum/2;j>=0;j--){
                if(j-nums[i-1]<0){
                    // 容量不足
                    dp[j] = dp[j];
                }else{
                    // 不装入或者装入
                    dp[j] = dp[j] || dp[j-nums[i-1]];
                }
            }
        }
        
        return dp[sum/2];
        
    }
}

```

```
Runtime: 26 ms, faster than 57.99% of Java online submissions for Partition Equal Subset Sum.
Memory Usage: 37.5 MB, less than 92.20% of Java online submissions for Partition Equal Subset Sum.
```

### 509. Fibonacci Number E

The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,

```
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), for N > 1.
Given N, calculate F(N).

Example 1:

Input: 2
Output: 1
Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.
Example 2:

Input: 3
Output: 2
Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.
Example 3:

Input: 4
Output: 3
Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.

```

```java
class Solution {
    public int fib(int N) {
        int f0 = 0;
        int f1 = 1;
        if(N<1){
            return 0;
        }
        
        for(int i=1;i<N;i++){
            int temp = f0+f1;
            f0 = f1;
            f1 = temp;
        }
        
        return f1;
    }
}
```

```
Runtime: 0 ms, faster than 100.00% of Java online submissions for Fibonacci Number.
Memory Usage: 36.2 MB, less than 64.26% of Java online submissions for Fibonacci Number.
```

### 887. Super Egg Drop

You are given K eggs, and you have access to a building with N floors from 1 to N. 

Each egg is identical in function, and if an egg breaks, you cannot drop it again.

You know that there exists a floor F with 0 <= F <= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break.

Each move, you may take an egg (if you have an unbroken one) and drop it from any floor X (with 1 <= X <= N). 

Your goal is to know with certainty what the value of F is.

What is the minimum number of moves that you need to know with certainty what F is, regardless of the initial value of F?

```

Example 1:

Input: K = 1, N = 2
Output: 2
Explanation: 
Drop the egg from floor 1.  If it breaks, we know with certainty that F = 0.
Otherwise, drop the egg from floor 2.  If it breaks, we know with certainty that F = 1.
If it didn't break, then we know with certainty F = 2.
Hence, we needed 2 moves in the worst case to know what F is with certainty.
Example 2:

Input: K = 2, N = 6
Output: 3
Example 3:

Input: K = 3, N = 14
Output: 4
 

Note:

1 <= K <= 100
1 <= N <= 10000
```

#### Solution 1

```java
class Solution {

    private int[][] dpTable;
    public int dp(int k,int n){
        int res = Integer.MAX_VALUE;
        // 状态转移
        if(k==1){
            this.dpTable[k][n] = n;
            return n;
        }
        // dp[k][n] 代表的是 还有 k 个鸡蛋去测试 n 层
        // basecase 就是 k=1 的时候，一个鸡蛋只能线性查找
        // basecase 另外一个就是 n=0 的时候，不需要扔鸡蛋
        
        if(n==0){
            this.dpTable[k][n]=0;
            return 0;
        }

        if(this.dpTable[k][n]!=Integer.MAX_VALUE){
            return this.dpTable[k][n];
        }

        for(int i=1;i<=n;i++){
            res = Math.min(res,Math.max(this.dp(k-1,i-1),this.dp(k,n-i))+1);
        }
        this.dpTable[k][n] = res;
        return res;
    }
    public int superEggDrop(int K, int N) {
        // 备忘录 dpTable
        this.dpTable = new int[K+1][N+1];
        for(int i=0;i<dpTable.length;i++){
            for(int j=0;j<dpTable[i].length;j++){
                this.dpTable[i][j] = Integer.MAX_VALUE;
            }
        }

        // 动态规划
        this.dp(K,N);

        return this.dpTable[K][N];


    }

}
```

超时

#### Solution 2 二分查找优化

```java
class Solution {

    private int[][] dpTable;
    public int dp(int k,int n){
        int res = Integer.MAX_VALUE;
        // 状态转移
        if(k==1){
            this.dpTable[k][n] = n;
            return n;
        }
        // dp[k][n] 代表的是 还有 k 个鸡蛋去测试 n 层
        // basecase 就是 k=1 的时候，一个鸡蛋只能线性查找
        // basecase 另外一个就是 n=0 的时候，不需要扔鸡蛋
        
        if(n==0){
            this.dpTable[k][n]=0;
            return 0;
        }

        if(this.dpTable[k][n]!=Integer.MAX_VALUE){
            return this.dpTable[k][n];
        }

        // 线性搜索
        // for(int i=1;i<=n;i++){
        //     res = Math.min(res,Math.max(this.dp(k-1,i-1),this.dp(k,n-i))+1);
        // }
        
        // 二分搜索
        int lo = 1;
        int hi = n;
        
        while(lo<=hi){
            int mid = (lo+hi)/2;
            int broken = this.dp(k-1,mid-1);
            int unBroken = this.dp(k,n-mid);
            
            if(broken > unBroken){
                hi = mid - 1;
                res = Math.min(res,broken+1);
            }else{
                lo = mid+1;
                res = Math.min(res,unBroken+1);
            }
        }
        this.dpTable[k][n] = res;
        return res;
    }
    public int superEggDrop(int K, int N) {
        // 备忘录 dpTable
        this.dpTable = new int[K+1][N+1];
        for(int i=0;i<dpTable.length;i++){
            for(int j=0;j<dpTable[i].length;j++){
                this.dpTable[i][j] = Integer.MAX_VALUE;
            }
        }

        // 动态规划
        this.dp(K,N);

        return this.dpTable[K][N];

    }

}
```

```
Runtime: 53 ms, faster than 26.87% of Java online submissions for Super Egg Drop.
Memory Usage: 40 MB, less than 50.24% of Java online submissions for Super Egg Drop.
```

### 1312. Minimum Insertion Steps to Make a String Palindrome

Given a string s. In one step you can insert any character at any index of the string.

Return the minimum number of steps to make s palindrome.

A Palindrome String is one that reads the same backward as well as forward.

```

Example 1:

Input: s = "zzazz"
Output: 0
Explanation: The string "zzazz" is already palindrome we don't need any insertions.
Example 2:

Input: s = "mbadm"
Output: 2
Explanation: String can be "mbdadbm" or "mdbabdm".
Example 3:

Input: s = "leetcode"
Output: 5
Explanation: Inserting 5 characters the string becomes "leetcodocteel".
Example 4:

Input: s = "g"
Output: 0
Example 5:

Input: s = "no"
Output: 1
 

Constraints:

1 <= s.length <= 500
All characters of s are lower case English letters.

```

```java
class Solution {
    public int minInsertions(String s) {
        // 最直观的想法就是双指针，一个从左往右一个从右往左同时移动
        // 判断 s[i] 是否等于 s[j]
        // 如果相同则说明这两个位置已成回文
        // 不相同则说明需要插入
        
        // 相同的时候不用多说，主要考虑不相同的时候，最小的插入次数
        // 假设为 a......b 这样子的最少需要两次插入(为方便表示，大写字母为后插入的字母)
        // 最少的插入方式为 aB.....bA 或者 Ba......Ab。此时是两次
        
        // 但是如果考虑 s[i] s[j]中间的字母，则会有如下情况
        // aaaaaaaab 这样子的时候最小需要一次插入即可完成回文
        // 也就是 baaaaaaaab
        // 通过这个情况，会发现如果我在发现 s[i] 和 s[j] 不相等的时候。有一种普世的过程，如下
        // aXXXXb 无论X是什么，我都可以考虑： 先把 s[i] 放到一边，只看 s[i+1...j] 这一段，也就是 XXXb 这一段。
        //                                  此时假设 XXXb 这一段 已是回文，那么就可以直接在 XXXb 的右边添加一个 a 从而形成回文
        //                                  若假设 XXXb 这一段 不是回文，我此时可以对 XXXb 进行递归调，重复第一行的过程，那么我是可以得到 XXXb 这一段的最小插入次数的
        //                                  再抽象一点就是 用插入次数为 "s[i+1....j]形成回文的最小次数 + 1"
        
        // 因为最终是要求最小的插入次数，所以不光一边需要检查最小，另一边也需要，那么 s[i.....j] 这一段的最小插入次数可以为 Min(s[i+1.....j],s[i.....j-1]) + 1
        
        // 当相同的时候 s[i.....j] 的最小插入次数取决于 s[i+1.....j-1]
        // 当不同的时候 s[i.....j] 的最小插入次数取决于 Min(s[i+1.....j],s[i.....j-1]) + 1
        // ok 开始用 动规 解决问题
        
        char[] sA = s.toCharArray();
        
//         // dp 状态定义
//         // dp[i][j] 代表 s[i....j] 变成回文的最小插入次数
        
//         int[][] dp = new int[sA.length][sA.length];
        
//         // basecase 就是 i==j 的时候为 0
        
//         // dp是一个二维数组，dp[i][j] 取决于 dp[i+1][j-1] 或 (dp[i+1][j],dp[i][j-1]) 需要保证是从basecase开始
//         for(int i=sA.length-2;i>=0;i--){
//             for(int j=i+1;j<sA.length;j++){
//                 if(sA[i]==sA[j]){
//                     dp[i][j] = dp[i+1][j-1];
//                 }else{
//                     dp[i][j] = Math.min(dp[i+1][j],dp[i][j-1])+1;
//                 }
//             }
//         }
        
//         return dp[0][sA.length-1];
        
        // 状态压缩
        // 直接从二维 dp 的变化来进行压缩，不考虑实际对题目的意义
        // 首先 dp[i][j] 只跟相邻的有关，所以可以进行压缩
        // 假设 dp 是 3X3 的
        // X  X  X
        // X  X  O
        // X  X  X
        // 那么 O 只和相邻的左、左下、下元素有关
        // 对于斜对角的左下元素，我们可以用一个变量来存储
        // 对于相邻的左和下元素，可以用一维数组来存储
        
        // dp 状态定义
        // dp[i][j] 代表 s[i....j] 变成回文的最小插入次数
        
        int[] dp = new int[sA.length];
        
        // basecase 就是 i==j 的时候为 0
        
        // dp是一个二维数组，dp[i][j] 取决于 dp[i+1][j-1] 或 (dp[i+1][j],dp[i][j-1]) 需要保证是从basecase开始
        for(int i=sA.length-2;i>=0;i--){
            int pre = 0;
            for(int j=i+1;j<sA.length;j++){
                int temp = dp[j];
                if(sA[i]==sA[j]){
                    dp[j] = pre;
                }else{
                    dp[j] = Math.min(dp[j],dp[j-1])+1;
                }
                pre = temp;
            }
            ;
        }
        
        return dp[sA.length-1];
    }
}
```

```
Runtime: 6 ms, faster than 100.00% of Java online submissions for Minimum Insertion Steps to Make a String Palindrome.
Memory Usage: 37.1 MB, less than 99.81% of Java online submissions for Minimum Insertion Steps to Make a String Palindrome.
```

### 1143. Longest Common Subsequence

Given two strings text1 and text2, return the length of their longest common subsequence.

A subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, "ace" is a subsequence of "abcde" while "aec" is not). A common subsequence of two strings is a subsequence that is common to both strings.

 

If there is no common subsequence, return 0.

```

Example 1:

Input: text1 = "abcde", text2 = "ace" 
Output: 3  
Explanation: The longest common subsequence is "ace" and its length is 3.
Example 2:

Input: text1 = "abc", text2 = "abc"
Output: 3
Explanation: The longest common subsequence is "abc" and its length is 3.
Example 3:

Input: text1 = "abc", text2 = "def"
Output: 0
Explanation: There is no such common subsequence, so the result is 0.
 

Constraints:

1 <= text1.length <= 1000
1 <= text2.length <= 1000
The input strings consist of lowercase English characters only.

```

```java
class Solution {
    private int [][] dp;
    public int longestCommonSubsequence(String text1, String text2) {
        // 首先想到的是 300. 最长上升子序列。不过思路还是不一样==
        
        // 直观的想法是，s1 s2 分别有一个指针从左到右遍历。
        // 判断 s1[i] == s2[j] 如果相同则说明 s[i] s[j] 的这个字母一定在 lcs 中
        // 不相同的时候，可以想到此时 i 位置 和 j 位置的 lcs 长度取决于 s1[i] s2[j-1] 或者 s1[i-1][j]
        
        // 动规开始
        // 状态定义，dp[i][j] 代表 s1[1...i] 和 s2[1....j] 中的 lcs 长度
        
        char[] s1 = text1.toCharArray();
        char[] s2 = text2.toCharArray();
        
        // 因为 text1 和 text2 最少有一个字符，为了方便看，使 dp 下标直接代表第几个字符
        this.dp = new int[s1.length+1][s2.length+1]; 
        
        // basecase 就是当 s1 或 s2 是空的时候，此时 dp[0][j] =0 dp[i][0]=0
        
        // 状态转移
        for(int i=1;i<=s1.length;i++){
            for(int j=1;j<=s2.length;j++){
                if(s1[i-1]==s2[j-1]){
                    dp[i][j] = dp[i-1][j-1]+1;
                }else{
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        
        return this.dp[s1.length][s2.length];
        
    }
}
```

```
Runtime: 7 ms, faster than 95.11% of Java online submissions for Longest Common Subsequence.
Memory Usage: 42.8 MB, less than 87.88% of Java online submissions for Longest Common Subsequence.
```

### 516. Longest Palindromic Subsequence

Given a string s, find the longest palindromic subsequence's length in s. You may assume that the maximum length of s is 1000.
```

Example 1:
Input:

"bbbab"
Output:
4
One possible longest palindromic subsequence is "bbbb".
 

Example 2:
Input:

"cbbd"
Output:
2
One possible longest palindromic subsequence is "bb".
 

Constraints:

1 <= s.length <= 1000
s consists only of lowercase English letters.
```

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        // 对于子序列和最值的问题，一般考虑动规
        // 子序列有两种通用的状态定义方式，
        // 如果没有涉及到两个字符串：
        //                          1. dp[i] 代表以 i 结尾的状态
        //                          2. dp[i][j] 代表 s[i...j] 的状态
        // 对于涉及到两个字符串的情况：
        //                          dp[i][j] 代表 s1[1...i] s2[1...j] 的状态
        
        // 对最长回文字串，直观思路会是：从字符串中间出发，分别向两头检查
        // 当 s[i] == s[j] 的时候，可以从上一状态 s[i+1....j-1] + 2 得到
        // 当 s[i] != s[j] 的时候，可以从 s[i+1...j] 和 s[i...j-1] 中取最大得到
        
        
        
        // 状态定义
        // dp[i][j] 代表 s[i....j] 中最长回文的长度
        int n = s.length();
        int[][] dp = new int[n][n];
        
        // basecase
        // 当 i > j 的时候不存在回文 此时都应为0
        // i = j 的时候 为 1
        for(int i=0;i<n;i++){
            dp[i][i] = 1;
        }
        
        // 状态转移
        for(int i=n-1;i>=0;i--){
            for(int j=i+1;j<n;j++){
                if(s.charAt(i)==s.charAt(j)){
                    dp[i][j] = dp[i+1][j-1]+2;
                }else{
                    dp[i][j] = Math.max(dp[i+1][j],dp[i][j-1]);
                }
            }
        }
        
        return dp[0][n-1];
        
        
    }
}
```

### 877. Stone Game

Alex and Lee play a game with piles of stones.  There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].

The objective of the game is to end with the most stones.  The total number of stones is odd, so there are no ties.

Alex and Lee take turns, with Alex starting first.  Each turn, a player takes the entire pile of stones from either the beginning or the end of the row.  This continues until there are no more piles left, at which point the person with the most stones wins.

Assuming Alex and Lee play optimally, return True if and only if Alex wins the game.
```
 

Example 1:

Input: piles = [5,3,4,5]
Output: true
Explanation: 
Alex starts first, and can only take the first 5 or the last 5.
Say he takes the first 5, so that the row becomes [3, 4, 5].
If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.
If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.
This demonstrated that taking the first 5 was a winning move for Alex, so we return true.
 

Constraints:

2 <= piles.length <= 500
piles.length is even.
1 <= piles[i] <= 500
sum(piles) is odd.

```

#### 双指针

```java
class Solution {
    public boolean stoneGame(int[] piles) {
        
        int al_st = 0;
        int l_st = 0;
        boolean alex = true;
        int i=0;
        int j = piles.length-1;
        while(i<j){
            if(alex){
                if(piles[i]>piles[j]){
                    al_st+=piles[i++];
                }
                else{
                    al_st+=piles[j--];
                }
            }
            else{
               if(piles[i]>piles[j]){
                    l_st+=piles[i];
                    i++;
                }
                else{
                    l_st+=piles[j--];
                } 
            }
        }
        return (al_st>l_st)?true:false;
    }
}
```

#### 动规解法

```java
class Solution {
    public boolean stoneGame(int[] piles) {
        
        // 参考https://labuladong.github.io/ebook/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98.html
        // 先后手问题属于博弈问题，后手状态会依据先手状态来转移，并且先手在选择后，相对而言会变成后手
        // 因为石头堆是从两边开始选择的，直观的想会考虑如下：
        //                                              作为先手，可以从两边选一堆，如果我选择的是右边的那一堆 piles[j] 剩下能得到的应该是从 [i...j-1]，反之则是从 [i+1...j] 中得到
        //                                              先手选完后，后手应依据其先手的左右选择，对应能拿到的最大为 [i...j-1] 中（先手选了 piles[j]）或者 [i+1...j-1] 中（先手选了 piles[i]）
        
        // 此时对于 dp 的定义考虑如下 dp[i][j] 表示能从 piles[i....j] 这些中获得的最大数量
        
        // 但是此时会发现，先后手会对 dp[i][j] 产生影响
        // 为了表示出先后手的不同影响，dp[i][j] 一个元组，表示先后手两种不同的情况下 能从 piles[i....j] 中获得的最大数量
        
        // 状态定义 dp[i][j][o] 代表能从 piles[i....j] 中获得的最大数量 o=0 表示先手 o=1 表示后手
        
        int n = piles.length;
        int[][][] dp = new int[n][n][2];
        
        // basecase i=j 的时候，先手拿走唯一的那一堆石头，后手能拿的只有 0
        for(int i=0;i<n;i++){
            dp[i][i][0] = piles[i];
            dp[i][i][1] = 0;
        }
        
        // 状态转移
        for(int l=2;l<=n;l++){
            for(int i=0;i<=n-l;i++){
                int j = i+l-1; // 斜着遍历二维dp
    
                // 先手选择后，就会作为下一次的后手，所以要加上下一次的后手情况
                int left = piles[i]+dp[i+1][j][1];
                int right = piles[j]+dp[i][j-1][1];
                
                if(left>right){
                    dp[i][j][0] = left;
                    dp[i][j][1] = dp[i+1][j][0]; //此时在先手选完后，后手变为剩下那些石头堆的先手
                }else{
                    dp[i][j][0] = right;
                    dp[i][j][1] = dp[i][j-1][0]; //此时在先手选完后，后手变为剩下那些石头堆的先手
                }
                
            }
        }
        
        return (dp[0][n-1][0] - dp[0][n-1][1]) > 0;
        
    }
}
```

### 股票买卖

#### 121. Best Time to Buy and Sell Stock

Say you have an array for which the ith element is the price of a given stock on day i.

If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Note that you cannot sell a stock before you buy one.

```
Example 1:

Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.
Example 2:

Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.

```

```java
class Solution {
    public int maxProfit(int[] prices) {
        // 对于股票买卖，一共有三种选择，买入、卖出、休息
        // 买入一定在卖出之前，卖出一定在买入之后
        // 休息可以是“持有股票的休息”或者是“不持有股票的休息”
        
        // 今天的最高利润依据昨天的选择，上动规
        
        // 只能进行一次交易
        
//         // 定义状态
//         // dp[i][s] 其中，i 代表第 i 天， s 有两种取值， 0 或者 1，分别代表 没有持有股票 和 持有股票
//         final int DAYS = prices.length;
//         final int STOCK_STATUS = 2;
        
//         int[][] dp = new int[DAYS+1][STOCK_STATUS];
        
//         // basecase
//         // dp[i][0]=0 第 0 天，买卖还未开始，利润应为 0
//         // dp[0][1]=-infinity 第 0 天，不可能持有股票，用负无穷表示不可能（方便 max 函数选择）
        
//         dp[0][0] = 0;
//         dp[0][1] = Integer.MIN_VALUE;
        
//         // 状态转移 i 代表 第 i 天
//         // dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i])
//         // 第 i 天没有持有股票，前一天可以没有持有股票，也可以持有股票但是在第 i 天卖出
//         // dp[i][1] = max(dp[i-1][1],dp[i-1][0] - prices[i])
//         // 第 i 天持有股票，前一天可以持有股票，也可以不持有股票但是在第 i 天买入（因为只能买入一次，此时前一天利润必定为 0）
        
//         for(int i=1;i<=DAYS;i++){
//             dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]+prices[i-1]);
//             dp[i][1] = Math.max(dp[i-1][1],0-prices[i-1]);
//         }
        
//         return dp[DAYS][0];
        
        
        // 空间压缩
        // 定义状态
        // dp[i][s] 其中，i 代表第 i 天， s 有两种取值， 0 或者 1，分别代表 没有持有股票 和 持有股票
        final int DAYS = prices.length;
        final int STOCK_STATUS = 2;
        
        // int[][] dp = new int[DAYS+1][STOCK_STATUS];
        int status_0 = 0;
        int status_1 = Integer.MIN_VALUE;
        
        // basecase
        // dp[i][0]=0 第 0 天，买卖还未开始，利润应为 0
        // dp[0][1]=-infinity 第 0 天，不可能持有股票，用负无穷表示不可能（方便 max 函数选择）
        
        // dp[0][0] = 0;
        // dp[0][1] = Integer.MIN_VALUE;
        
        // 状态转移 i 代表 第 i 天
        // dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i])
        // 第 i 天没有持有股票，前一天可以没有持有股票，也可以持有股票但是在第 i 天卖出
        // dp[i][1] = max(dp[i-1][1],dp[i-1][0] - prices[i])
        // 第 i 天持有股票，前一天可以持有股票，也可以不持有股票但是在第 i 天买入（因为只能买入一次，此时前一天利润必定为 0）
        
        for(int i=1;i<=DAYS;i++){
            status_0 = Math.max(status_0,status_1+prices[i-1]);
            status_1 = Math.max(status_1,0-prices[i-1]);
        }
        
        return status_0;
        
    }
}
```

```
Runtime: 1 ms, faster than 98.77% of Java online submissions for Best Time to Buy and Sell Stock.
Memory Usage: 38.6 MB, less than 11.78% of Java online submissions for Best Time to Buy and Sell Stock.
```

#### 122. Best Time to Buy and Sell Stock II

Say you have an array prices for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).

Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).
```
Example 1:

Input: [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
Example 2:

Input: [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
             engaging multiple transactions at the same time. You must sell before buying again.
Example 3:

Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
 

Constraints:

1 <= prices.length <= 3 * 10 ^ 4
0 <= prices[i] <= 10 ^ 4
```

```java
class Solution {
    public int maxProfit(int[] prices) {
        // 对于股票买卖，一共有三种选择，买入、卖出、休息
        // 买入一定在卖出之前，卖出一定在买入之后
        // 休息可以是“持有股票的休息”或者是“不持有股票的休息”
        
        // 今天的最高利润依据昨天的选择，上动规
        
        // 不限制交易次数
        
//         // 定义状态
//         // dp[i][s] 其中，i 代表第 i 天， s 有两种取值， 0 或者 1，分别代表 没有持有股票 和 持有股票
//         final int DAYS = prices.length;
//         final int STOCK_STATUS = 2;
        
//         int[][] dp = new int[DAYS+1][STOCK_STATUS];
        
//         // basecase
//         // dp[i][0]=0 第 0 天，买卖还未开始，利润应为 0
//         // dp[0][1]=-infinity 第 0 天，不可能持有股票，用负无穷表示不可能（方便 max 函数选择）
        
//         dp[0][0] = 0;
//         dp[0][1] = Integer.MIN_VALUE;
        
//         // 状态转移 i 代表 第 i 天
//         // dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i])
//         // 第 i 天没有持有股票，前一天可以没有持有股票，也可以持有股票但是在第 i 天卖出
//         // dp[i][1] = max(dp[i-1][1],dp[i-1][0] - prices[i])
//         // 第 i 天持有股票，前一天可以持有股票，也可以不持有股票但是在第 i 天买入
        
//         for(int i=1;i<=DAYS;i++){
//             dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]+prices[i-1]);
//             dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]-prices[i-1]);
//         }
        
//         return dp[DAYS][0];
        
        // 空间压缩
        // 定义状态
        // dp[i][s] 其中，i 代表第 i 天， s 有两种取值， 0 或者 1，分别代表 没有持有股票 和 持有股票
        final int DAYS = prices.length;
        final int STOCK_STATUS = 2;
        
        // int[][] dp = new int[DAYS+1][STOCK_STATUS];
        int status_0 = 0;
        int status_1 = Integer.MIN_VALUE;
        
        // basecase
        // dp[i][0]=0 第 0 天，买卖还未开始，利润应为 0
        // dp[0][1]=-infinity 第 0 天，不可能持有股票，用负无穷表示不可能（方便 max 函数选择）
        
        // dp[0][0] = 0;
        // dp[0][1] = Integer.MIN_VALUE;
        
        // 状态转移 i 代表 第 i 天
        // dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i])
        // 第 i 天没有持有股票，前一天可以没有持有股票，也可以持有股票但是在第 i 天卖出
        // dp[i][1] = max(dp[i-1][1],dp[i-1][0] - prices[i])
        // 第 i 天持有股票，前一天可以持有股票，也可以不持有股票但是在第 i 天买入（因为只能买入一次，此时前一天利润必定为 0）
        
        for(int i=1;i<=DAYS;i++){
            int temp = status_0;
            status_0 = Math.max(status_0,status_1+prices[i-1]);
            status_1 = Math.max(status_1,temp-prices[i-1]);
        }
        
        return status_0;
        
    }
}
```

```
Runtime: 1 ms, faster than 85.47% of Java online submissions for Best Time to Buy and Sell Stock II.
Memory Usage: 38.9 MB, less than 14.19% of Java online submissions for Best Time to Buy and Sell Stock II.
```

#### 309. Best Time to Buy and Sell Stock with Cooldown

Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:

You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)
Example:
```
Input: [1,2,3,0,2]
Output: 3 
Explanation: transactions = [buy, sell, cooldown, buy, sell]
```

```java
class Solution {
    public int maxProfit(int[] prices) {
        // 对于股票买卖，一共有三种选择，买入、卖出、休息
        // 买入一定在卖出之前，卖出一定在买入之后
        // 休息可以是“持有股票的休息”或者是“不持有股票的休息”
        
        // 今天的最高利润依据昨天的选择，上动规
        
        // 不限制交易次数
        // 有冷冻期，为 1 天，只需修改转移方程，如果在第 i 天买的时候需要看第 i-2 天的状态 (因为必不能从第 i-1 天买入)
        
//         // 定义状态
//         // dp[i][s] 其中，i 代表第 i 天， s 有两种取值， 0 或者 1，分别代表 没有持有股票 和 持有股票
//         final int DAYS = prices.length;
//         final int STOCK_STATUS = 2;
        
//         int[][] dp = new int[DAYS+1][STOCK_STATUS];
        
//         // basecase
//         // dp[i][0]=0 第 0 天，买卖还未开始，利润应为 0
//         // dp[0][1]=-infinity 第 0 天，不可能持有股票，用负无穷表示不可能（方便 max 函数选择）
        
//         dp[0][0] = 0;
//         dp[0][1] = Integer.MIN_VALUE;
        
//         // 状态转移 i 代表 第 i 天
//         // dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i])
//         // 第 i 天没有持有股票，前一天可以没有持有股票，也可以持有股票但是在第 i 天卖出
//         // dp[i][1] = max(dp[i-1][1],dp[i-1][0] - prices[i])
//         // 第 i 天持有股票，前一天可以持有股票，也可以不持有股票但是在第 i 天买入
        
//         for(int i=1;i<=DAYS;i++){
//             dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]+prices[i-1]);
//             if(i!=1){
//                 dp[i][1] = Math.max(dp[i-1][1],dp[i-2][0]-prices[i-1]);
//             }else{
//                 // 第二天买入
//                 dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]-prices[i-1]);
//             }
//         }
        
//         return dp[DAYS][0];
        
        // 空间压缩
        // 定义状态
        // dp[i][s] 其中，i 代表第 i 天， s 有两种取值， 0 或者 1，分别代表 没有持有股票 和 持有股票
        final int DAYS = prices.length;
        final int STOCK_STATUS = 2;
        
        // int[][] dp = new int[DAYS+1][STOCK_STATUS];
        int status_0,status_0_pre;
        int status_1;
        
        
        // basecase
        // dp[i][0]=0 第 0 天，买卖还未开始，利润应为 0
        // dp[0][1]=-infinity 第 0 天，不可能持有股票，用负无穷表示不可能（方便 max 函数选择）
        
        // dp[0][0] = 0;
        // dp[0][1] = Integer.MIN_VALUE;
        
        status_0 = 0;
        status_0_pre = 0;
        status_1 = Integer.MIN_VALUE;
        
        // 状态转移 i 代表 第 i 天
        // dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i])
        // 第 i 天没有持有股票，前一天可以没有持有股票，也可以持有股票但是在第 i 天卖出
        // dp[i][1] = max(dp[i-1][1],dp[i-1][0] - prices[i])
        // 第 i 天持有股票，前一天可以持有股票，也可以不持有股票但是在第 i 天买入
        
        for(int i=1;i<=DAYS;i++){
            int temp = status_0;
            // dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]+prices[i-1]);
            status_0 = Math.max(status_0,status_1 + prices[i-1]);
            // if(i!=1){
            //     dp[i][1] = Math.max(dp[i-1][1],dp[i-2][0]-prices[i-1]);
            // }else{
            //     // 第二天买入
            //     dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]-prices[i-1]);
            // }
            status_1 = Math.max(status_1,status_0_pre - prices[i-1]);
            status_0_pre = temp;
        }
        
        return status_0;
    }
}
```

```
Runtime: 0 ms, faster than 100.00% of Java online submissions for Best Time to Buy and Sell Stock with Cooldown.
Memory Usage: 36.9 MB, less than 14.88% of Java online submissions for Best Time to Buy and Sell Stock with Cooldown.
```

#### 714. Best Time to Buy and Sell Stock with Transaction Fee

Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee.

You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)

Return the maximum profit you can make.

```
Example 1:
Input: prices = [1, 3, 2, 8, 4, 9], fee = 2
Output: 8
Explanation: The maximum profit can be achieved by:
Buying at prices[0] = 1
Selling at prices[3] = 8
Buying at prices[4] = 4
Selling at prices[5] = 9
The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
Note:

0 < prices.length <= 50000.
0 < prices[i] < 50000.
0 <= fee < 50000.
```

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        // 对于股票买卖，一共有三种选择，买入、卖出、休息
        // 买入一定在卖出之前，卖出一定在买入之后
        // 休息可以是“持有股票的休息”或者是“不持有股票的休息”
        
        // 今天的最高利润依据昨天的选择，上动规
        
        // 不限制交易次数，但是要付交易费
        
//         // 定义状态
//         // dp[i][s] 其中，i 代表第 i 天， s 有两种取值， 0 或者 1，分别代表 没有持有股票 和 持有股票
//         final int DAYS = prices.length;
//         final int STOCK_STATUS = 2;
        
//         int[][] dp = new int[DAYS+1][STOCK_STATUS];
        
//         // basecase
//         // dp[i][0]=0 第 0 天，买卖还未开始，利润应为 0
//         // dp[0][1]=-infinity 第 0 天，不可能持有股票，用负无穷表示不可能（方便 max 函数选择）
        
//         dp[0][0] = 0;
//         dp[0][1] = Integer.MIN_VALUE;
        
//         // 状态转移 i 代表 第 i 天
//         // dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i])
//         // 第 i 天没有持有股票，前一天可以没有持有股票，也可以持有股票但是在第 i 天卖出
//         // dp[i][1] = max(dp[i-1][1],dp[i-1][0] - prices[i])
//         // 第 i 天持有股票，前一天可以持有股票，也可以不持有股票但是在第 i 天买入
        
//         for(int i=1;i<=DAYS;i++){
//             dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]+prices[i-1]);
//             dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]-prices[i-1]-fee);
//         }
        
//         return dp[DAYS][0];
        
        // 空间压缩
        // 定义状态
        // dp[i][s] 其中，i 代表第 i 天， s 有两种取值， 0 或者 1，分别代表 没有持有股票 和 持有股票
        final int DAYS = prices.length;
        final int STOCK_STATUS = 2;
        
        // int[][] dp = new int[DAYS+1][STOCK_STATUS];
        int status_0 = 0;
        int status_1 = Integer.MIN_VALUE;
        
        // basecase
        // dp[i][0]=0 第 0 天，买卖还未开始，利润应为 0
        // dp[0][1]=-infinity 第 0 天，不可能持有股票，用负无穷表示不可能（方便 max 函数选择）
        
        // dp[0][0] = 0;
        // dp[0][1] = Integer.MIN_VALUE;
        
        // 状态转移 i 代表 第 i 天
        // dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i])
        // 第 i 天没有持有股票，前一天可以没有持有股票，也可以持有股票但是在第 i 天卖出
        // dp[i][1] = max(dp[i-1][1],dp[i-1][0] - prices[i])
        // 第 i 天持有股票，前一天可以持有股票，也可以不持有股票但是在第 i 天买入（因为只能买入一次，此时前一天利润必定为 0）
        
        for(int i=1;i<=DAYS;i++){
            int temp = status_0;
            status_0 = Math.max(status_0,status_1+prices[i-1]);
            status_1 = Math.max(status_1,temp-prices[i-1]-fee);
        }
        
        return status_0;
        
    }
}
```

```
Runtime: 3 ms, faster than 93.90% of Java online submissions for Best Time to Buy and Sell Stock with Transaction Fee.
Memory Usage: 48.2 MB, less than 8.05% of Java online submissions for Best Time to Buy and Sell Stock with Transaction Fee.
```

#### 123. Best Time to Buy and Sell Stock III

Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most two transactions.

Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).

```
Example 1:

Input: prices = [3,3,5,0,0,3,1,4]
Output: 6
Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.
Example 2:

Input: prices = [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.
Example 3:

Input: prices = [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
Example 4:

Input: prices = [1]
Output: 0


Constraints:

1 <= prices.length <= 105
0 <= prices[i] <= 105
```

```java
class Solution {
    public int maxProfit(int[] prices) {
        // 对于股票买卖，一共有三种选择，买入、卖出、休息
        // 买入一定在卖出之前，卖出一定在买入之后
        // 休息可以是“持有股票的休息”或者是“不持有股票的休息”
        
        // 今天的最高利润依据昨天的选择，上动规
        
        // 限制交易次数为两次
        
//         final int DAYS = prices.length;
//         final int STOCK_STATUS = 2;
//         final int MAX_K = 2;
        
//         // 定义状态
//         // dp[i][k][s] 其中，i 代表第 i 天，k 为截至到第 i 天，进行的交易次数， s 有两种取值， 0 或者 1，分别代表 没有持有股票 和 持有股票
//         int[][][] dp = new int[DAYS+1][MAX_K+1][STOCK_STATUS];
        
        
//         // basecase
//         // dp[0][0][0]=0 第 0 天，买卖还未开始，利润应为 0
//         // dp[0][0][1]=-infinity 第 0 天，不可能持有股票，用负无穷表示不可能（方便 max 函数选择）
//         for(int i=0;i<=MAX_K;i++){
//             dp[0][i][0] = 0;
//             dp[0][i][1] = Integer.MIN_VALUE;
//         }
        
        
        
//         // 状态转移
//         // dp[i][k][0]= max(dp[i-1][k][0],dp[i-1][k][1]+prices[i])
//         // dp[i][k][1] = max(dp[i-1][k][1],dp[i-1][k-1][0]-prices[i])
//         for(int i=1;i<=DAYS;i++){
//             for(int j=1;j<=MAX_K;j++){
//                 dp[i][j][0] = Math.max(dp[i-1][j][0],dp[i-1][j][1]+prices[i-1]);
//                 if(j==0)
//                     dp[i][j][1] = Math.max(dp[i-1][j][1],0-prices[i-1]);
//                 else{
//                     dp[i][j][1] = Math.max(dp[i-1][j][1],dp[i-1][j-1][0]-prices[i-1]);
//                 }
//             }
//         }
        
//         return dp[DAYS][MAX_K][0];
        
        // 空间压缩
        final int DAYS = prices.length;
        final int STOCK_STATUS = 2;
        final int MAX_K = 2;
        
        
        
        // 定义状态
        // dp[i][k][s] 其中，i 代表第 i 天，k 为截至到第 i 天，进行的交易次数， s 有两种取值， 0 或者 1，分别代表 没有持有股票 和 持有股票
        // int[][][] dp = new int[DAYS+1][MAX_K+1][STOCK_STATUS];
        int dpi10,dpi11,dpi20,dpi21;
        
        // basecase
        // dp[0][0][0]=0 第 0 天，买卖还未开始，利润应为 0
        // dp[0][0][1]=-infinity 第 0 天，不可能持有股票，用负无穷表示不可能（方便 max 函数选择）
        // for(int i=0;i<=MAX_K;i++){
        //     dp[0][i][0] = 0;
        //     dp[0][i][1] = Integer.MIN_VALUE;
        // }
        dpi10 = 0;
        dpi20 = 0;
        dpi11 = Integer.MIN_VALUE;
        dpi21 = Integer.MIN_VALUE;
        
        
        
        // 状态转移
        // dp[i][k][0]= max(dp[i-1][k][0],dp[i-1][k][1]+prices[i])
        // dp[i][k][1] = max(dp[i-1][k][1],dp[i-1][k-1][0]-prices[i])
        for(int i=1;i<=DAYS;i++){
            // for(int j=1;j<=MAX_K;j++){
            //     dp[i][j][0] = Math.max(dp[i-1][j][0],dp[i-1][j][1]+prices[i-1]);
            //     if(j==0)
            //         dp[i][j][1] = Math.max(dp[i-1][j][1],0-prices[i-1]);
            //     else{
            //         dp[i][j][1] = Math.max(dp[i-1][j][1],dp[i-1][j-1][0]-prices[i-1]);
            //     }
            // }
            
            dpi20 = Math.max(dpi20,dpi21+prices[i-1]);
            dpi21 = Math.max(dpi21,dpi10-prices[i-1]);
            dpi10 = Math.max(dpi10,dpi11+prices[i-1]);
            dpi11 = Math.max(dpi11,0-prices[i-1]);
            
        }
        
        return dpi20;
    }
}
```

```

```

#### 188. Best Time to Buy and Sell Stock IV

Say you have an array for which the i-th element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most k transactions.

Note:
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

```
Example 1:

Input: [2,4,1], k = 2
Output: 2
Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.
Example 2:

Input: [3,2,6,5,0,3], k = 2
Output: 7
Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.
             Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.

```

```java
class Solution {
    private int maxProfit_k_inf(int[] prices) {
        // 当 k > n/2
        int n = prices.length;
        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            int temp = dp_i_0;
            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
            dp_i_1 = Math.max(dp_i_1, temp - prices[i]);
        }
        return dp_i_0;
    }
    
    public int maxProfit(int k, int[] prices) {
        // 对于股票买卖，一共有三种选择，买入、卖出、休息
        // 买入一定在卖出之前，卖出一定在买入之后
        // 休息可以是“持有股票的休息”或者是“不持有股票的休息”
        
        // 今天的最高利润依据昨天的选择，上动规
        
        // 出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了
        
        // 对于股票买卖，一共有三种选择，买入、卖出、休息
        // 买入一定在卖出之前，卖出一定在买入之后
        // 休息可以是“持有股票的休息”或者是“不持有股票的休息”
        
        // 今天的最高利润依据昨天的选择，上动规
        
        // 限制交易次数为k次
        // 一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了
        
        final int DAYS = prices.length;
        final int STOCK_STATUS = 2;
        final int MAX_K = k;
        
        if(MAX_K>DAYS/2){
            return maxProfit_k_inf(prices);
        }
        
        // 定义状态
        // dp[i][k][s] 其中，i 代表第 i 天，k 为截至到第 i 天，进行的交易次数， s 有两种取值， 0 或者 1，分别代表 没有持有股票 和 持有股票
        int[][][] dp = new int[DAYS+1][MAX_K+1][STOCK_STATUS];
        
        
        // basecase
        // dp[0][0][0]=0 第 0 天，买卖还未开始，利润应为 0
        // dp[0][0][1]=-infinity 第 0 天，不可能持有股票，用负无穷表示不可能（方便 max 函数选择）
        for(int i=0;i<=MAX_K;i++){
            dp[0][i][0] = 0;
            dp[0][i][1] = Integer.MIN_VALUE;
        }
        
        
        
        // 状态转移
        // dp[i][k][0]= max(dp[i-1][k][0],dp[i-1][k][1]+prices[i])
        // dp[i][k][1] = max(dp[i-1][k][1],dp[i-1][k-1][0]-prices[i])
        for(int i=1;i<=DAYS;i++){
            for(int j=1;j<=MAX_K;j++){
                dp[i][j][0] = Math.max(dp[i-1][j][0],dp[i-1][j][1]+prices[i-1]);
                if(j==0)
                    dp[i][j][1] = Math.max(dp[i-1][j][1],0-prices[i-1]);
                else{
                    dp[i][j][1] = Math.max(dp[i-1][j][1],dp[i-1][j-1][0]-prices[i-1]);
                }
            }
        }
        
        return dp[DAYS][MAX_K][0];
        
    }
}
```

```
Runtime: 5 ms, faster than 46.21% of Java online submissions for Best Time to Buy and Sell Stock IV.
Memory Usage: 40.5 MB, less than 5.51% of Java online submissions for Best Time to Buy and Sell Stock IV.
```

## 贪心

### 435. Non-overlapping Intervals

Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.

```

Example 1:

Input: [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.
Example 2:

Input: [[1,2],[1,2],[1,2]]
Output: 2
Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.
Example 3:

Input: [[1,2],[2,3]]
Output: 0
Explanation: You don't need to remove any of the intervals since they're already non-overlapping.
 

Note:

You may assume the interval's end point is always bigger than its start point.
Intervals like [1,2] and [2,3] have borders "touching" but they don't overlap each other.

```

```java
class Solution {
    // 参考：https://labuladong.github.io/ebook/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98.html
    
    private int intervalSchedule(int[][] intervals){
        // 区间调度算法
        // 先按照 end 进行排序
        // 从区间集合 intvs 中选择一个区间 x，这个 x 是在当前所有区间中结束最早的（end 最小）。
        // 把所有与 x 区间相交的区间从区间集合 intvs 中删除。
        // 重复步骤 1 和 2，直到 intvs 为空为止。之前选出的那些 x 就是最大不相交子集。
        
        // basecase
        if(intervals.length==0){
            return 0;
        }
        
        // 按照 end 排序
        Arrays.sort(intervals,new Comparator<int[]>(){
            public int compare(int[] a, int[] b) {
                return a[1] - b[1];
            }
        });
        
        // 排序后 第一个元素 即为所有区间中结束最早的
        int x_end = intervals[0][1];
        
        // 计数，有多少不重叠区间
        int count = 1; // 至少一个
        
        for(int[] intv: intervals){
            int start = intv[0];
            if(start>=x_end){
                count++;
                x_end = intv[1];
            }
        }
        
        return count;
        
    }
    
    public int eraseOverlapIntervals(int[][] intervals) {
        // 使用区间调度算法
        // 因为 intervalSchedule 返回的是 不重叠区间的数量
        // 那么依据题意 只需返回 intervals.length - intervalSchedule 即(重叠的区间数量)
        
        return intervals.length - this.intervalSchedule(intervals);
        
        
    }
}
```

```
Runtime: 4 ms, faster than 29.31% of Java online submissions for Non-overlapping Intervals.
Memory Usage: 41.9 MB, less than 19.40% of Java online submissions for Non-overlapping Intervals.
```

### 452. Minimum Number of Arrows to Burst Balloons

There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons.

An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.

```
Example:

Input:
[[10,16], [2,8], [1,6], [7,12]]

Output:
2

Explanation:
One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).
```

```java
class Solution {
    
    private int intervalSchedule(int[][] intervals){
        // 区间调度算法
        // 先按照 end 进行排序
        // 从区间集合 intvs 中选择一个区间 x，这个 x 是在当前所有区间中结束最早的（end 最小）。
        // 把所有与 x 区间相交的区间从区间集合 intvs 中删除。
        // 重复步骤 1 和 2，直到 intvs 为空为止。之前选出的那些 x 就是最大不相交子集。
        
        // basecase
        if(intervals.length==0){
            return 0;
        }
        
        // 按照 end 排序
        Arrays.sort(intervals,new Comparator<int[]>(){
            public int compare(int[] a, int[] b) {
                return a[1] - b[1];
            }
        });
        
        // 排序后 第一个元素 即为所有区间中结束最早的
        int x_end = intervals[0][1];
        
        // 计数，有多少不重叠区间
        int count = 1; // 至少一个
        
        for(int[] intv: intervals){
            int start = intv[0];
            if(start> x_end){ // 边界条件修改
                count++;
                x_end = intv[1];
            }
        }
        
        return count;
        
    }
    
    public int findMinArrowShots(int[][] points) {
        // 如果最多有 n 个不重叠的区间，那么就至少需要 n 个箭头穿透所有区间
        // 擦边也算，所以区间调度算法修改一下边界条件即可
        
        return this.intervalSchedule(points);
        
    }
}
```

```
Runtime: 21 ms, faster than 39.23% of Java online submissions for Minimum Number of Arrows to Burst Balloons.
Memory Usage: 56.9 MB, less than 17.37% of Java online submissions for Minimum Number of Arrows to Burst Balloons.
```

## BFS DFS

### 200. Number of Islands

```java
Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

 

Example 1:

Input: grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
Output: 1
Example 2:

Input: grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
Output: 3
```

#### Solution BFS 2

```java
class Solution {
    private char[][] map;
    private boolean[][] visited;
    private void bfsHelper(int row, int col){
        // bfs 所有 1 的位置
        // 并将 visited 置为 true
        
        if(map[row][col]=='1'&&!visited[row][col]){
            visited[row][col]=true;
            if(row-1>-1){
                bfsHelper(row-1,col);
            }
            if(row+1<map.length){
                bfsHelper(row+1,col);
            }
            if(col-1>-1){
                bfsHelper(row,col-1);
            }
            if(col+1<map[0].length){
                bfsHelper(row,col+1);
            }
        }else{
            return ;
        }
        
    }
    
    public int numIslands(char[][] grid) {
        // 每当遇到 island 的数字，就从该数字开始进行 bfs
        // 并将遇到的位置 设置为 visited = true 减少重复遍历
        map = grid;
        int ROW = map.length;
        int COL = ROW==0?0:map[0].length;
        visited = new boolean[ROW][COL];
        
        
        int res = 0;
        
        for(int i=0;i<ROW;i++){
            for(int j=0;j<COL;j++){
                if(!visited[i][j]){
                    // 没有拜访过
                    if(map[i][j]=='1'){
                        // 如果是岛就开始 bfs
                        res++;
                        bfsHelper(i,j);
                    }
                }
            }
        }
        
        return res;
        
    }
}
```

```
Runtime: 1 ms, faster than 99.95% of Java online submissions for Number of Islands.
Memory Usage: 41.6 MB, less than 96.38% of Java online submissions for Number of Islands.
```

#### UF 并查集 1

```java
class Solution {
    
    // 并查集解法 UF
    
    
    // 并查集
    // 采用 weighted + path comparess 并查集
    private int[] points;
    private int[] sz;
    private void UF(int pointsNumber){
        this.points = new int[pointsNumber];
        this.sz = new int[pointsNumber];
        
        for(int i=0;i<pointsNumber;i++){
            this.points[i] = i;
            this.sz[i] = 1;
        }
    }
    
    
    // find 节点的连通根节点 lgN
    private int find(int point){
        while(this.points[point]!=point){
            // path compress
            this.points[point] = this.points[this.points[point]];
            // find root
            point = this.points[point];
        }
        
        return this.points[point];
    }
    
    // connected 判断是否连通 lgN
    private boolean connected(int p, int q){
        return this.find(p)==this.find(q);
    }
    
    // union 连通节点 lgN
    private void union(int p, int q){
        int rootP = this.find(p);
        int rootQ = this.find(q);
        
        // 已连通
        if(rootP==rootQ)
            return;
        
        // 保证 N*M 永远都是根节点
        if(this.sz[rootP]>this.sz[rootQ]){
            this.points[rootQ] = rootP;
            this.sz[rootP]+=this.sz[rootP];
        }else{
            this.points[rootP] = rootQ;
            this.sz[rootQ]+=this.sz[rootP];
        }
    }
    
    public int numIslands(char[][] grid) {
        // 初始化
        final int N = grid.length;
        if(N==0){
            return 0;
        }
        final int M = grid[0].length;
        this.UF(N*M);
        
        for(int i=0;i<N;i++){
            for(int j=0;j<M;j++){
                if(grid[i][j]=='1'){
                    if (i-1>-1&&grid[i-1][j] == '1') {
                         this.union(i * M + j, (i-1) * M + j);
                     }
                     if (i+1<N&&grid[i+1][j] == '1') {
                         this.union(i * M + j, (i+1) * M + j);
                     }
                     if (j-1>-1&&grid[i][j-1] == '1') {
                         this.union(i * M + j, i * M + j - 1);
                     }
                     if (j+1<M&&grid[i][j+1] == '1') {
                         this.union(i * M + j, i * M + j  + 1);
                     }
                }else{
                    if (i-1>-1&&grid[i-1][j] == '0') {
                         this.union(i * M + j, (i-1) * M + j);
                     }
                     if (i+1<N&&grid[i+1][j] == '0') {
                         this.union(i * M + j, (i+1) * M + j);
                     }
                     if (j-1>-1&&grid[i][j-1] == '0') {
                         this.union(i * M + j, i * M + j - 1);
                     }
                     if (j+1<M&&grid[i][j+1] == '0') {
                         this.union(i * M + j, i * M + j  + 1);
                     }
                }
            }
        }
        
        HashSet<Integer> temp = new HashSet<>();
        
        int res = 0;
        for(int i=0;i<N;i++){
            for(int j=0;j<M;j++){
                if(grid[i][j]=='1'){
                    int root = this.find(i*M+j);
                    if(!temp.contains(root)){
                        temp.add(root);
                        res++;
                    }
                        
                }
            }
        }
        
        return res;
    }
}
```


```
Runtime: 9 ms, faster than 7.15% of Java online submissions for Number of Islands.
Memory Usage: 41.6 MB, less than 91.99% of Java online submissions for Number of Islands.
```

用 BFS 不香吗，就当练习了一下 UF 吧

### 130. Surrounded Regions

Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.

A region is captured by flipping all 'O's into 'X's in that surrounded region.
```
Example:

X X X X
X O O X
X X O X
X O X X
After running your function, the board should be:

X X X X
X X X X
X X X X
X O X X
```

#### Solution BFS 1

```java
class Solution {
    // 普遍的做法是扫矩阵的四条边，如果有O，则用 DFS 遍历，将所有连着的O都变成另一个字符，比如 @，这样剩下的O都是被包围的，然后将这些O变成X，把$变回O就行了
    private char[][] map;
    private boolean[][] visited;
    private void bfsHelper(int row, int col){
        // bfs 所有 O 的位置
        // 并将 visited 置为 true
        
        if(map[row][col]=='O'&&!visited[row][col]){
            visited[row][col]=true;
            map[row][col] = '@';
            if(row-1>-1){
                bfsHelper(row-1,col);
            }
            if(row+1<map.length){
                bfsHelper(row+1,col);
            }
            if(col-1>-1){
                bfsHelper(row,col-1);
            }
            if(col+1<map[0].length){
                bfsHelper(row,col+1);
            }
        }else{
            return ;
        }
        
    }
    
    public void solve(char[][] board) {
        // 每当遇到 island 的数字，就从该数字开始进行 bfs
        // 并将遇到的位置 设置为 visited = true 减少重复遍历
        map = board;
        int ROW = map.length;
        int COL = ROW==0?0:map[0].length;
        visited = new boolean[ROW][COL];
        
        // 先从两边查找 O
        for(int i=0;i<ROW;i++){
            if(map[i][0]=='O'&&!visited[i][0]){
                 bfsHelper(i,0);
            }
            if(map[i][COL-1]=='O'&&!visited[i][COL-1]){
                 bfsHelper(i,COL-1);
            }
        }
        
        for(int i=0;i<COL;i++){
            if(map[0][i]=='O'&&!visited[0][i]){
                 bfsHelper(0,i);
            }
            if(map[ROW-1][i]=='O'&&!visited[ROW-1][i]){
                 bfsHelper(ROW-1,i);
            }
        }
        
        for(int i=0;i<ROW;i++){
            for(int j=0;j<COL;j++){
                if(map[i][j]=='O'){
                    map[i][j]='X';
                }
                if(map[i][j]=='@'){
                    map[i][j] = 'O';
                }
            }
        }
        
    }
}
```

```
Runtime: 1 ms, faster than 99.78% of Java online submissions for Surrounded Regions.
Memory Usage: 41.4 MB, less than 82.24% of Java online submissions for Surrounded Regions.
```

#### UF 并查集 2

```java
class Solution {
    // 并查集解法 UF
    // 可以通过设置一个 dummy 节点表示边界，如果 "O" 没有和 dummy 边界相连通，就将其变成 "X"
    
    
    // 并查集
    // 采用 path comparess 并查集
    private int[] points;
    private void UF(int pointsNumber){
        this.points = new int[pointsNumber+1];
        // 并查集初始化 points[pointsNumber] 为 dummy 边界
        for(int i=0;i<=pointsNumber;i++){
            this.points[i] = i;
        }
    }
    
    
    // find 节点的连通根节点 lgN
    private int find(int point){
        while(this.points[point]!=point){
            // path compress
            this.points[point] = this.points[this.points[point]];
            // find root
            point = this.points[point];
        }
        
        return this.points[point];
    }
    
    // connected 判断是否连通 lgN
    private boolean connected(int p, int q){
        return this.find(p)==this.find(q);
    }
    
    // union 连通节点 lgN
    private void union(int p, int q){
        int rootP = this.find(p);
        int rootQ = this.find(q);
        
        // 已连通
        if(rootP==rootQ)
            return;
        
        // 保证 N*M 永远都是根节点
        if(this.points[rootP]>this.points[rootQ]){
            this.points[rootQ] = rootP;
        }else{
            this.points[rootP] = rootQ;
        }
    }
    
    
    
    public void solve(char[][] board) {
        // 初始化
        final int N = board.length;
        if(N==0){
            return;
        }
        final int M = board[0].length;
        this.UF(N*M);
        
        // 进行联通
        for(int i=0;i<N;i++){
            for(int j=0;j<M;j++){
                if(board[i][j]=='O'){
                    // 判断是否是在边界
                    if(i==0||j==0||i==N-1||j==M-1){
                        // 在边界就和 dummy 节点相连通
                        this.union(i*M+j,N*M);
                    }else{
                        // 和四周都是 O 的节点相连通
                        if (i-1>-1&&board[i-1][j] == 'O') {
                             this.union(i * M + j, (i-1) * M + j);
                         }
                         if (i+1<N&&board[i+1][j] == 'O') {
                             this.union(i * M + j, (i+1) * M + j);
                         }
                         if (j-1>-1&&board[i][j-1] == 'O') {
                             this.union(i * M + j, i * M + j - 1);
                         }
                         if (j+1<M&&board[i][j+1] == 'O') {
                             this.union(i * M + j, i * M + j  + 1);
                         }
                    }
                }
            }
        }
        
        // 将和 dummy 连通的节点变为 X
        
        for(int i=0;i<N;i++){
            for(int j=0;j<M;j++){
                if(this.find(i*M+j)!=N*M){
                    board[i][j]='X';
                }
            }
        }
        
    }
}
```

```
Runtime: 9 ms, faster than 9.60% of Java online submissions for Surrounded Regions.
Memory Usage: 41.3 MB, less than 89.62% of Java online submissions for Surrounded Regions.
```

效率很差，就当作练习一下并查集。  
原因是因为为了保证连通 dummy 节点的树根节点一定是 N*M，不能很好的用加权的结构。

## 并查集

### 261. Graph Valid Tree

Given n nodes labeled from 0 to n-1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.

```
Example 1:
Input: n = 5, and edges = [[0,1], [0,2], [0,3], [1,4]]
Output: trueExample 2:
Input: n = 5, and edges = [[0,1], [1,2], [2,3], [1,3], [1,4]]
Output: falseNote: you can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0,1] is the same as [1,0] and thus will not appear together in edges.
```

```java
class Solution {
    // 并查集解法 UF
    // 采用 weighted + path comparess 并查集
    private int[] points;
    private int[] sz;
    private void UF(int pointsNumber){
        this.points = new int[pointsNumber];
        this.sz = new int[pointsNumber];

        for(int i=0;i<pointsNumber;i++){
            this.points[i] = i;
            this.sz[i] = 1;
        }
    }


    // find 节点的连通根节点 lgN
    private int find(int point){
        while(this.points[point]!=point){
            // path compress
            this.points[point] = this.points[this.points[point]];
            // find root
            point = this.points[point];
        }

        return this.points[point];
    }

    // connected 判断是否连通 lgN
    private boolean connected(int p, int q){
        return this.find(p)==this.find(q);
    }

    // union 连通节点 lgN
    private void union(int p, int q){
        int rootP = this.find(p);
        int rootQ = this.find(q);

        // 已连通
        if(rootP==rootQ)
            return;

        if(this.sz[rootP]>this.sz[rootQ]){
            this.points[rootQ] = rootP;
            this.sz[rootP]+=this.sz[rootP];
        }else{
            this.points[rootP] = rootQ;
            this.sz[rootQ]+=this.sz[rootP];
        }
    }
    public boolean validTree(int n, int[][] edges) {
        // 先检查边集合是否等于 n-1
        final int EDGESLENGTH = edges.length;
        if(EDGESLENGTH!=n-1)
            return false;

        this.UF(n);

        for(int i=0;i<EDGESLENGTH;i++){
            // 检查是否有环
            if(this.find(edges[i][0])==this.find(edges[i][1])){
                return false;
            }
            this.union(edges[i][0],edges[i][1]);
        }

        return true;

    }
}
```

```
Runtime: 0 ms, faster than 100.00% of Java online submissions for Graph Valid Tree.
Memory Usage: 39.8 MB, less than 73.28% of Java online submissions for Graph Valid Tree.
```

### 323. Number of Connected Components in an Undirected Graph

Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph.

```
Example 1:
Input: n = 5 and edges = [[0, 1], [1, 2], [3, 4]]

     0          3
     |          |
     1 --- 2    4 

Output: 2
Example 2:
Input: n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]]

     0           4
     |           |
     1 --- 2 --- 3

Output:  1
Note:
You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.
```

```java
class Solution {
    // 并查集解法 UF
    // 采用 weighted + path comparess 并查集
    private int[] points;
    private int[] sz;
    private void UF(int pointsNumber){
        this.points = new int[pointsNumber];
        this.sz = new int[pointsNumber];

        for(int i=0;i<pointsNumber;i++){
            this.points[i] = i;
            this.sz[i] = 1;
        }
    }


    // find 节点的连通根节点 lgN
    private int find(int point){
        while(this.points[point]!=point){
            // path compress
            this.points[point] = this.points[this.points[point]];
            // find root
            point = this.points[point];
        }

        return this.points[point];
    }

    // connected 判断是否连通 lgN
    private boolean connected(int p, int q){
        return this.find(p)==this.find(q);
    }

    // union 连通节点 lgN
    private void union(int p, int q){
        int rootP = this.find(p);
        int rootQ = this.find(q);

        // 已连通
        if(rootP==rootQ)
            return;

        if(this.sz[rootP]>this.sz[rootQ]){
            this.points[rootQ] = rootP;
            this.sz[rootP]+=this.sz[rootP];
        }else{
            this.points[rootP] = rootQ;
            this.sz[rootQ]+=this.sz[rootP];
        }
    }

    private int getCount(){
        int res=0;
        for(int i=0;i<this.points.length;i++){
            if(find(this.points[i])==i){
                res++;
            }
        }
        return res;
    }
    public int countComponents(int n, int[][] edges) {
        // 直接链接判断
        final int EDGESNUMBER = edges.length;
        if(n==0){
            return 0;
        }
        // 初始化并查集
        this.UF(n);
        // 连接
        for(int i=0;i<EDGESNUMBER;i++){
            this.union(edges[i][0],edges[i][1]);
        }

        return this.getCount();

    }
}
```

```
Runtime: 1 ms, faster than 100.00% of Java online submissions for Number of Connected Components in an Undirected Graph.
Memory Usage: 39.7 MB, less than 88.79% of Java online submissions for Number of Connected Components in an Undirected Graph.
```

### 547. Friend Circles

There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.

Given a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.

```
Example 1:

Input: 
[[1,1,0],
 [1,1,0],
 [0,0,1]]
Output: 2
Explanation:The 0th and 1st students are direct friends, so they are in a friend circle. 
The 2nd student himself is in a friend circle. So return 2.
 

Example 2:

Input: 
[[1,1,0],
 [1,1,1],
 [0,1,1]]
Output: 1
Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends, 
so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.

 

Constraints:

1 <= N <= 200
M[i][i] == 1
M[i][j] == M[j][i]
```

```java
class Solution {
    // 并查集解法 UF
    // 采用 weighted + path comparess 并查集
    private int[] points;
    private int[] sz;
    private void UF(int pointsNumber){
        this.points = new int[pointsNumber];
        this.sz = new int[pointsNumber];

        for(int i=0;i<pointsNumber;i++){
            this.points[i] = i;
            this.sz[i] = 1;
        }
    }


    // find 节点的连通根节点 lgN
    private int find(int point){
        while(this.points[point]!=point){
            // path compress
            this.points[point] = this.points[this.points[point]];
            // find root
            point = this.points[point];
        }

        return this.points[point];
    }

    // connected 判断是否连通 lgN
    private boolean connected(int p, int q){
        return this.find(p)==this.find(q);
    }

    // union 连通节点 lgN
    private void union(int p, int q){
        int rootP = this.find(p);
        int rootQ = this.find(q);

        // 已连通
        if(rootP==rootQ)
            return;

        if(this.sz[rootP]>this.sz[rootQ]){
            this.points[rootQ] = rootP;
            this.sz[rootP]+=this.sz[rootP];
        }else{
            this.points[rootP] = rootQ;
            this.sz[rootQ]+=this.sz[rootP];
        }
    }

    private int getCount(){
        int res=0;
        for(int i=0;i<this.points.length;i++){
            if(find(this.points[i])==i){
                res++;
            }
        }
        return res;
    }
    public int findCircleNum(int[][] M) {
        // 连通解决
        if(M.length==0){
            return 0;
        }
        
        this.UF(M.length);
        for(int i=0;i<M.length;i++){
            for(int j=0;j<M[0].length;j++){
                if(M[i][j]==1){
                    this.union(i,j);
                }
            }
        }
        
        return this.getCount();
    }
}
```

```
Runtime: 1 ms, faster than 77.88% of Java online submissions for Friend Circles.
Memory Usage: 39.9 MB, less than 93.39% of Java online submissions for Friend Circles.
```

## 回溯法

### 980. Unique Paths III

```
On a 2-dimensional grid, there are 4 types of squares:

1 represents the starting square.  There is exactly one starting square.
2 represents the ending square.  There is exactly one ending square.
0 represents empty squares we can walk over.
-1 represents obstacles that we cannot walk over.
Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.

 

Example 1:

Input: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
Output: 2
Explanation: We have the following two paths: 
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
Example 2:

Input: [[1,0,0,0],[0,0,0,0],[0,0,0,2]]
Output: 4
Explanation: We have the following four paths: 
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)
Example 3:

Input: [[0,1],[2,0]]
Output: 0
Explanation: 
There is no path that walks over every empty square exactly once.
Note that the starting and ending square can be anywhere in the grid.
 

Note:

1 <= grid.length * grid[0].length <= 20
```

```java
class Solution {
    int row, col; // 地图
    boolean[][] visted; // 备忘录
    
    int x, y; // 起始位置
    
    public int uniquePathsIII(int[][] grid) {
        row = grid.length;
        col = grid[0].length;
        visted = new boolean[row][col];
        int count=0; //可行走的空位个数，防止重复行走
        int res = 0; //路条数
        
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                if(grid[i][j] == 0){
                    count++;
                }
                if(grid[i][j] == 1){
                    x = i;
                    y = j;
                }
            }
        }
        dfs(x, y, grid, visted, count);
        
        return res;
        
    }
    
    public dfs(int x, int y, int[][] grid, boolean[][] visted, int count){
        if(x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || visted[x][y] || grid[x][y] == -1){
            return;
        }
        if(grid[x][y] == 2 && count == -1){
            res++;
            return;
        }

        
        visted[x][y] = true;
        dfs(x + 1, y, grid, visted, count - 1);
        dfs(x - 1, y, grid, visted, count - 1);
        dfs(x, y + 1, grid, visted, count - 1);
        dfs(x, y - 1, grid, visted, count - 1);
        visted[x][y] = false;
    }
}
```

## 数据结构相关

### 146. LRU Cache

Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.

Implement the LRUCache class:

LRUCache(int capacity) Initialize the LRU cache with positive size capacity.
int get(int key) Return the value of the key if the key exists, otherwise return -1.

void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.

Follow up:
Could you do get and put in O(1) time complexity?

```
Example 1:

Input
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
Output
[null, null, null, 1, null, -1, null, -1, 3, 4]

Explanation
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // cache is {1=1}
lRUCache.put(2, 2); // cache is {1=1, 2=2}
lRUCache.get(1);    // return 1
lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}
lRUCache.get(2);    // returns -1 (not found)
lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}
lRUCache.get(1);    // return -1 (not found)
lRUCache.get(3);    // return 3
lRUCache.get(4);    // return 4
 

Constraints:

1 <= capacity <= 3000
0 <= key <= 3000
0 <= value <= 104
At most 3 * 104 calls will be made to get and put.
```

```java
class LRUCache {
    // 开放的API分析：
    // 1. 存储的 cache 中应有时序，最先访问过的或最新添加的内容应为最新使用过的 (类栈结构)
    // 2. 存储的 cache 中应支持快速查找，使用 key 能找到对应的 value
    // 3. 因为访问内容会导致该内容时序发生变化，cache 应支持快速插入和删除操作
    // 使用 hashtable + doulinkedlist
    
    final private int capacity; // cache 容量
    private int size; // 当前容量
    final private HashMap<Integer,Node> cacheMapping; // cache mapping
    final private Node head,tail; // doulinkedlist 头和尾
    
    private boolean isFull(){
        return this.size==this.capacity;
    }
    
    class Node{
        // doulinkedlist
        // 只能从尾部添加新元素，保证类栈结构
        
        int key;
        int val;
    
        Node pre;
        Node next;
        
        public Node(int key, int val){
            // 存储 hashtable 的 key
            Node.this.key = key;
            Node.this.val = val;
        }
    }
    
    private void addNode(int key,int val){
        // 向 doulinkedlist 中添加新的节点
        // 只从尾部添加
        Node newNode = new Node(key,val);
        Node oldPre = this.tail.pre;
        oldPre.next = newNode;
        newNode.pre = oldPre;
        newNode.next = this.tail;
        this.tail.pre = newNode;
    }
    
    private void addNode(Node newNode){
        // 向 doulinkedlist 中添加新的节点
        // 只从尾部添加
        Node oldPre = this.tail.pre;
        oldPre.next = newNode;
        newNode.pre = oldPre;
        newNode.next = this.tail;
        this.tail.pre = newNode;
    }
    
    private void removeNode(Node removeNode){
        // 从 doulinkedlist 中移除某一内容
        Node preNode = removeNode.pre;
        Node nextNode = removeNode.next;
        
        preNode.next = nextNode;
        nextNode.pre = preNode;
    }
    
    private Node removeFromHead(){
        // 从头部移除一个内容
        // 此时移除的即为最不常用的
        if(this.size!=0){
            Node removeNode = this.head.next;
            this.head.next = removeNode.next;
            removeNode.next.pre = this.head;
            return removeNode;
        }
        return null;
    }
    
    private void makeFirst(int key){
        // 将指定内容变成优先程度最高的
        Node oldNode = this.cacheMapping.get(key);
        
        this.removeNode(oldNode);
        this.addNode(oldNode);
    }
    
    private void addNewCache(int key, int val){
        // 向 cache 中添加新的内容
        if(this.cacheMapping.containsKey(key)){
            // 已存在，更新
            this.removeNode(this.cacheMapping.get(key)); // 删除旧内容
        }else{
            // 不存在内容
            // 判断是否容量已满
            if(this.isFull()){
                // 容量已满，从头移走一个最不常用的
                this.cacheMapping.remove(this.removeFromHead().key);
            }else{
                this.size++;
            }
        }
        Node newNode = new Node(key,val); // 更新/创建内容
        
        this.addNode(newNode);

        this.cacheMapping.put(key,newNode);
        
    }
    
    private void removeCache(int key){
        // 向 cache 中删除内容
        this.size--;
        this.removeNode(this.cacheMapping.get(key));
        this.cacheMapping.remove(key);
    }
    
    
    // 开放API--------------------------------------------------------------------------------------
        
    public LRUCache(int defineCapacity){
        this.capacity = defineCapacity;
        this.size = 0;
        this.cacheMapping = new HashMap<>();
        
        this.head = new Node(0,0);
        this.tail = new Node(0,0);
        
        this.head.next = this.tail;
        this.tail.pre = this.head;
    }
    
    public void put(int key,int val){
        // 添加新的值
        this.addNewCache(key,val);
    }
    
    public int get(int key){
        // 访问某一值
        if(!this.cacheMapping.containsKey(key))
            return -1;
        
        Node getNode = this.cacheMapping.get(key);
        this.makeFirst(key);
        
        return getNode.val;
        
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

```
Runtime: 14 ms, faster than 53.10% of Java online submissions for LRU Cache.
Memory Usage: 47.1 MB, less than 13.73% of Java online submissions for LRU Cache.
```

使用库

```java
class LRUCache {
    int cap;
    LinkedHashMap<Integer, Integer> cache = new LinkedHashMap<>();
    public LRUCache(int capacity) { 
        this.cap = capacity;
    }

    public int get(int key) {
        if (!cache.containsKey(key)) {
            return -1;
        }
        // 将 key 变为最近使用
        makeRecently(key);
        return cache.get(key);
    }

    public void put(int key, int val) {
        if (cache.containsKey(key)) {
            // 修改 key 的值
            cache.put(key, val);
            // 将 key 变为最近使用
            makeRecently(key);
            return;
        }

        if (cache.size() >= this.cap) {
            // 链表头部就是最久未使用的 key
            int oldestKey = cache.keySet().iterator().next();
            cache.remove(oldestKey);
        }
        // 将新的 key 添加链表尾部
        cache.put(key, val);
    }

    private void makeRecently(int key) {
        int val = cache.get(key);
        // 删除 key，重新插入到队尾
        cache.remove(key);
        cache.put(key, val);
    }
}
```

```
Runtime: 16 ms, faster than 34.99% of Java online submissions for LRU Cache.
Memory Usage: 47.5 MB, less than 13.73% of Java online submissions for LRU Cache.
```

###  460. LFU Cache

```java
public class LFUCache {
    HashMap<Integer, Integer> keyVals; // Key val 映射
    HashMap<Integer, Integer> keyCounts; // key frequency 映射
    HashMap<Integer, LinkedHashSet<Integer>> countKeySets; // 每个不同 frequency 对应 key list
    int capacity;
    int min;

    public LFUCache(int capacity) {
        this.capacity = capacity;
        this.min = -1;
        keyVals = new HashMap<Integer, Integer>();
        keyCounts = new HashMap<Integer, Integer>();
        countKeySets = new HashMap<Integer, LinkedHashSet<Integer>>();
        countKeySets.put(1, new LinkedHashSet<Integer>());
    }

    public int get(int key) {
        if(!keyVals.containsKey(key)){
            return -1;
        }
        int count = keyCounts.get(key);
        keyCounts.put(key, count+1);
        countKeySets.get(count).remove(key);
        if(count == min && countKeySets.get(count).size() == 0){
            min++;
        }
        if(!countKeySets.containsKey(count+1)){
            countKeySets.put(count+1, new LinkedHashSet<Integer>());
        }
        countKeySets.get(count+1).add(key);
        return keyVals.get(key);
    }

    public void put(int key, int value) {
        if(capacity <= 0){
            return;
        }

        if(keyVals.containsKey(key)){
            keyVals.put(key, value);
            get(key);
            return;
        }
        if(keyVals.size() >= capacity){
            int leastFreq = countKeySets.get(min).iterator().next();
            keyVals.remove(leastFreq);
            keyCounts.remove(leastFreq);
            countKeySets.get(min).remove(leastFreq);
        }
        keyVals.put(key, value);
        keyCounts.put(key, 1);
        countKeySets.get(1).add(key);
        min = 1;
    }
}

/**
 * Your LFUCache object will be instantiated and called as such:
 * LFUCache obj = new LFUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

```
Runtime: 22 ms, faster than 65.26% of Java online submissions for LFU Cache.
Memory Usage: 54 MB, less than 6.26% of Java online submissions for LFU Cache.
```